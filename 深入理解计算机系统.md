[TOC]

# 计算机系统漫游

* 计算机系统是由硬件和系统软件组成的

## 信息就是位+上下文

大部分的现代操作系统都使用ASCII标准类表示文本字符,这种方式实际上就是用一个唯一的单字节大小的整数值来表示每个字符

> C语言是贝尔实验室的Dennis Ritchie于1969年~1973年间创建的.美国国家标准学会(American National Standards Institute, ANSI)在1989年颁布了ANSI C的标准,后来C语言的标准化成了国际标准化组织(International Standards Organization, ISO)的责任.这些标准定义了C语言和一系列函数库,即所谓的C标准库.Kernighan和Ritchie在他们的经典著作中描述了ANSI C,这本著作被人们满怀感情地称为"K&R" .用Ritchie的话·来说, C语言是“古怪的、有缺陷的,但同时也是一个巨大的成功”.为什么会成功呢?
>
> * c语言与Unix操作系统关系密切.C从一开始就是作为一种用于Unix系统的程序语言开发出来的.大部分Unix内核(操作系统的核心部分),以及所有支撑工具和函数库都是用C语言编写的.20世纪70年代后期到80年代初期, Unix风行于高等院校,许多人开始接触C语言并喜欢上它.因为Unix几乎全部是用C编写的,它可以很为便地移植到新的机器上,这种特点为C和Unix赢得丁更为广泛的支特.
> * C语言小而简单.C语言的设计是由一个人而非一个协会掌控的,因此这是一个简洁明了、没有什么冗赘的设计. K&R这本书用大量的例子和练习描述了完整的C语言及其标准库,而全书不过261页.C语言的简单使它相对而言易于学习,也易于移植到不同的计算机上.
> * C语言是为实践目的设计的.C语言是设计用来实现Unix操作系统的.后来,其他人发现能够用这门语言无障碍地编写他们想要的程序.

## 程序被其他程序翻译成不同的格式

![image-20210701114239932](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210701114239932.png)

* 预处理阶段.预处理器(cpp)根据以字符#开头的命令,修改原始的C程序.比如hello.c中第1行的#include <stdio.h>命令告诉预处理器读取系统头文stdio.h的内容,并把它直接插入程序文本中.结果就得到了另一个C程序,通是以.i作为文件扩展名.
* 编译阶段.编译器(ccl)将文本文件hello.i翻译成文本文件hello.s,它包含一个汇编语言程序.
* 汇编阶段.接下来,汇编器(as)将hello.s翻译成机器语言指令,把这些指令打包成一种叫做可重定位目标程序(relocatable object program)的格式,并将结果保存在目标文件hello.o中.hello.o文件是一个二进制文件,它包含的17个字节是函数main的指令编码.如果我们在文本编辑器中打开hello.o文件,将看到一堆乱码.
* 链接阶段.请注意, hello程序调用了printf函数,它是每个C编译器都提供的标准C库中的一个函数.printf函数存在于一个名为printf.o的单独的预编译好了的目标文件中,而这个文件必须以某种方式合并到我们的hello..程序中.链接器(ld)就负责处理这种合并.结果就得到hello文件,它是一个可执行目标文件(或者简称为可执行文件),可以被加载到内存中,由系统执行.

> GCC是GNU(GNU是GNU's Not Unix的缩写)项目开发出来的众多有用工具之一. GNU项目是1984年由Richard Stallman发起的一个免税的慈善项目.该项目的目标非常宏大,就是开发出一个完整的类Unix的系统,其源代码能够不受限制地被修改和传播.GNU项目已经开发出了一个包含Unix操作系统的所有主要部件的环境,但内核除外, 内核是由Linux项目独立发展而来的.GNU环境包括EMACS编辑器、GCC编译器、GDB调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件.GCC编译器已经发展到支持许多不同的语言,能够为许多不同的机器生成代码.支持的语言包括C. C++、Fortran, Java, Pascal、面向对象C语言(Objective-C)和Ada.
>
> GNU项目取得了非凡的成绩,但是却常常被忽略.现代开放源码运动(通常和Linux联系在一起)的思想起源是GNU项目中自由软件(free software)的概念.(此处的free为自由言论(free speech)中的“自由”之意,而非免费啤酒(free beer)中的“免费”之意.)而且, Linux如此受欢迎在很大程度上还要归功于GNU工具,它们给Linux内核提供了环境.

## 了解编译系统如何工作是大有益处的

* 优化程序性能
* 理解链接时出现的错误
* 避免安全漏洞

## 处理器读并解释储存在内存中的指令

shell是一个命令行解释器,它输出一个提示符,等待输入一个命令行,然后执行这个命令.如果该命令行的第一个单词不是一个内置的shell命令,那么shell就会假设这是一个可执行文件的名字,它将加载并运行这个文件.

### 系统的硬件组成

#### 总线

贯穿整个系统的是一组电子管道,称作总线,它携带信息字节并负责在各个部件间传递.通常总线被设计成传送定长的字节块,也就是字(word).字中的字节数(即字长)是·个基本的系统参数,各个系统中都不尽相同.现在的大多数机器字长要么是4个字节(32位),要么是8个字节(64位)

#### I/O设备

I/0(输入/输出)设备是系统与外部世界的联系通道.

#### 主存

主存是一个临时存储设备,在处理器执行程序时,用来存放程序和程序处理的数据.从物理上来说,主存是由一组动态随机存取存储器(DRAM)芯片组成的.从逻辑上来说,存储器是一个线性的字节数组,每个字节都有其唯一的地址(数组索引),这些地址是从零开始的.一般来说,组成程序的每条机器指令都由不同数量的字节构成.与C程序变量相对应的数据项的大小是根据类型变化的.

#### 处理器

中央处理单元(CPU) ,简称处理器,是解释(或执行)存储在主存中指令的引擎.处理器的核心是一个大小为一个字的存储设备(或寄存器),称为程序计数器(PC).在任何时刻, PC都指向主存中的某条机器语言指令(即含有该条指令的地址),e从系统通电开始,直到系统断电,处理器一直在不断地执行程序计数器指向的指令,再更新程序计数器,使其指向下一条指令.处理器看上去是按照一个非常简单的指令执行模型来操作的,这个模型是由指令集架构决定的.在这个模型中,指令按照严格的顺序执行,而执行一条指令包含执行一系列的步骤.处理器从程序计数器指向的内存处读取指令,解释指令中的位,执行该指令指示的简单操作,然后更新PC,使其指向下一条指令,而这条指令并不一定和在内存中刚刚执行的指令相邻.

* 加载:从主存复制一个字节或者一个字到寄存器,以覆盖寄存器原来的内容.
* 存储:从寄存器复制一个字节或者一个字到主存的某个位置,以覆盖这个位置上原来的内容.
* 操作:把两个寄存器的内容复制到ALU, ALU对这两个字做算术运算,并将结果存放到一个寄存器中,以覆盖该寄存器中原来的内容.
* 跳转:从指令本身中抽取一个字,并将这个字复制到程序计数器(PC)中,以覆盖PC中原来的值.

## 高速缓存

根据机械原理,较大的存储设备要比较小的存储设备运行得慢,而快速设备的造价远高于同类的低速设备

![image-20210701114314292](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210701114314292.png)

类似地,一个典型的寄存器文件只存储几百字节的信息,而主存里可存放几十亿字节.然而,处理器从寄存器文件中读数据比从主存中读取几乎要快100倍.更麻烦的是,随着这些年半导体技术的进步,这种处理器与主存之间的差距还在持续增大.加快处理器的运行速度比加快主存的运行速度要容易和便宜得多.

针对这种处理器与主存之间的差异,系统设计者采用了更小更快的存储设备,称为高速缓存存储器(cache memory,简称为cache或高速缓存),作为暂时的集结区域,存放处理器近期可能会需要的信息.

高速缓存的局部性原理,即程序具有访问局部区域里的数据和代码的趋势.通过让高速缓存里存放可能经常访问的数据,大部分的内存操作都能在快速的高速缓存中完成.

![image-20210628220049247](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210628220049247.png)

<center>存储器层次结构</center>

## 操作系统管理硬件

我们可以把操作系统看成是应用程序和硬件之间插入的一层软件.

所有应用程序对硬件的操作尝试都必须通过操作系统.

操作系统有两个基本功能: (1)防止硬件被失控的应用程序滥用; (2)向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备.操作系统通过几个基本的抽象概念(进程、虚拟内存和文件)来实现这两个功能.

### 进程

程序在现代系统上运行时,操作系统会提供一种假象,就好像系统上只有这个程序在运行.程序看上去是独占地使用处理器、主存和I/O设备.处理器看上去就像在不间断地一条接一条地执行程序中的指令,即该程序的代码和数据是系统内存中唯一的对象.这些假象是通过进程的概念来实现的,进程是计算机科学中最重要和最成功的概念之一

进程是操作系统对一个正在运行的程序的一种抽象.在一个系统上可以同时运行多个进程,而每个进程都好像在独占地使用硬件.而并发运行,则是说一个进程的指令和另一个进程的指令是交错执行的.在大多数系统中,需要运行的进程数是多于可以运行它们的CPU个数的.传统系统在一个时刻只能执行一个程序,而先进的多核处理器同时能够执行多个程序.无论是在单核还是多核系统中,一个CPU看上去都像是在并发地执行多个进程,这是通过处理器在进程间切换来实现的.操作系统实现这种交错执行的机制称为上下文切换.

操作系统保持跟踪进程运行所需的所有状态信息.这种状态,也就是上下文,包括许多信息,比如PC和寄存器文件的当前值,以及主存的内容.在任何一个时刻,单处理器系统都只能执行一个进程的代码.当操作系统决定要把控制权从当前进程转移到某个新进程时,就会进行上下文切换,即保存当前进程的上下文、恢复新进程的上下文,然后将控制权传递到新进程.新进程就会从它上次停止的地方开始.

### 线程

尽管通常我们认为一个进程只有单一的控制流,但是在现代系统中,一个进程实际上可以由多个称为线程的执行单元组成,每个线程都运行在进程的上下文中,并共享同样的代码和全局数据

由于网络服务器中对并行处理的需求,线程成为越来越重要的编程模型,因为多线程之间比多进程之间更容易共享数据,也因为线程一般来说都比进程更高效.当有多处理器可用的时候,多线程也是一种使得程序可以运行得更快的方法

### 虚拟内存

虚拟内存是一个抽象概念,它为每个进程提供了一个假象,即每个进程都在独占地使用主存.每个进程看到的内存都是一致的,称为虚拟地址空间

* 程序代码和数据.对所有的进程来说,代码是从同一固定地址开始,紧接着的是和C全局变量相对应的数据位置.
* 堆.代码和数据区后紧随着的是运行时堆.代码和数据区在进程一开始运行时就被指定了大小,与此不同,当调用像malloc和free这样的C标准库函数时,堆可以在运行时动态地扩展和收缩.
* 共享库.大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域.共享库的概念非常强大,也相当难懂.
* 栈.位于用户虚拟地址空间顶部的是用户栈,编译器用它来实现函数调用.和堆一样,用户栈在程序执行期间可以动态地扩展和收缩.特别地,每次我们调用一个函数时,栈就会增长;从一个函数返回时,栈就会收缩.
* 内核虚拟内存.地址空间顶部的区域是为内核保留的.不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数.相反,它们必须调用内核来执行这些操作.虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互,包括对处理器生成的每个地址的硬件翻译.基本思想是把一个进程虚拟内存的内容存储在磁盘上,然后用主存作为磁盘的高速缓存.

#### 虚拟地址的由来

在早期的计算机中，程序是直接运行到物理内存（可以理解为内存条上的内存）上的.也就是说，程序运行的时候直接访问的就是物理地址.如果，我们的一个计算机只运行一个程序，那么只有这个程序所需要的内存空间不超过物理内存空间的大小，就不会有问题.但是，我们正在希望的是在某个时候同时运行多个程序.那么这个时候，就会有个一个问题，==计算机如何把有限的物理内存分配给多个程序使用==呢？

某台计算机总的内存大小是128M，现在同时运行两个程序A和B，A需占用内存10M，B需占用内存110.计算机在给程序分配内存时会采取这样的方法：先将内存中的前10M分配给程序A，接着再从内存中剩余的118M中划分出110M分配给程序B.这种分配方法可以保证程序A和程序B都能运行，但是这种简单的内存分配策略问题很多.

* 问题1：进程地址空间不隔离.由于程序都是直接访问物理内存，所以恶意程序可以随意修改别的进程的内存数据，以达到破坏的目的.有些非恶意的，==但是有bug的程序也可能不小心修改了其它程序的内存数据，就会导致其它程序的运行出现异常==.这种情况对用户来说是无法容忍的，因为用户希望使用计算机的时候，其中一个任务失败了，至少不能影响其它的任务.
* 问题2：==内存使用效率低==.在A和B都运行的情况下，如果用户又运行了程序C，而程序C需要20M大小的内存才能运行，而此时系统只剩下8M的空间可供使用，所以此时系统必须在已运行的程序中选择一个将该程序的数据暂时拷贝到硬盘上，释放出部分空间来供程序C使用，然后再将程序C的数据全部装入内存中运行.可以想象得到，在这个过程中，有大量的数据在装入装出，导致效率十分低下.
* 问题3：程序运行的地址不确定.当内存中的剩余空间可以满足程序C的要求后，==操作系统会在剩余空间中随机分配一段连续的20M大小的空间给程序C使用，因为是随机分配的，所以程序运行的地址是不确定的==.但是我们的某些硬件是需要在固定的地址上去开始运行的，但是如果这个地址后边被我们的程序占有，那么我们对这块内存的修改，就可能导致某些硬件不可用了.

为了解决上述问题，人们想到了一种变通的方法，就是增加一个中间层，利用一种间接的地址访问方法访问物理内存.按照这种方法，程序中访问的内存地址不再是实际的物理内存地址，而是一个虚拟地址，然后由操作系统将这个虚拟地址映射到适当的物理内存地址上.这样，只要操作系统处理好虚拟地址到物理内存地址的映射，就可以保证不同的程序最终访问的内存地址位于不同的区域，彼此没有重叠，就可以达到内存地址空间隔离的效果.

#### 虚拟地址和物理地址映射

物理地址：物理地址空间是实在的存在于计算机中的一个实体，在每一台计算机中保持唯一独立性.我们可以称它为物理内存；如在32位的机器上，物理空间的大小理论上可以达到2^32字节(4GB)，但如果实际装了512的内存，那么其物理地址真正的有效部分只有512MB = 512 * 1024 KB = 512 * 1024 * 1024 B（0x00000000~0x1fffffff）.其他部分是无效的

==虚拟地址：虚拟地址并不真实存在于计算机中.每个进程都分配有自己的虚拟空间，而且只能访问自己被分配使用的空间==.理论上，虚拟空间受物理内存大小的限制，如给有4GB内存，那么虚拟地址空间的地址范围就应该是0x00000000~0xFFFFFFFF.每个进程都有自己独立的虚拟地址空间.这样每个进程都能访问自己的地址空间，这样做到了有效的隔离

在上面我们提到了合理的内存管理机制.我们这里虚拟地址和物理地址之间的映射是通过==MMU（内存管理单元）==来完成的



![img](https:////upload-images.jianshu.io/upload_images/15774762-b0ec5de9cf127f27.png?imageMogr2/auto-orient/strip|imageView2/2/w/971/format/webp)

我们平时操作的内存其实都是通过操作虚拟地址的内存单元.通过通过MMU的映射来间接的操作我们的物理地址

## 系统之间利用网络通信

系统漫游至此,我们一直是把系统视为一个孤立的硬件和软件的集合体.实际上,系统经常通过网络和其他系统连接到一起.从一个单独的系统来看,网络可视为一个I/O设备.当系统从主存复制一串字节到网络适配器时,数据流经过网络到达另一台机器,而不是比如说到达本地磁盘驱动器.相似地,系统可以读取从其他机器发送来的数据,并把数据复制到自己的主存.

![image-20210628215945841](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210628215945841.png)

随着Internet这样的全球网络的出现,从一台主机复制信息到另外一台主机已经成为计算机系统最重要的用途之一.比如,像电子邮件、即时通信、万维网、FTP和telnet这样的应用都是基于网络复制信息的功能.

## Amdahl定律

Gene Amdahl,计算领域的早期先锋之一,对提升系统某一部分性能所带来的效果做出了简单却有见地的观察.这个观察被称为Amdahl定律(Amdahl's law),该定律的主要思想是,当我们对系统的某个部分加速时,其对系统整体性能的影响取决于该部分的重要性和加速程度.若系统执行某应用程序需要时间为$T_{old}$.假设系统某部分所需执行时间与该时间的比例为$\alpha$,而该部分性能提升比例为k.即该部分初始所需时间为$aT_{old}$,现在所需时间为$aT_{old}/k$.因此,总的执行时间应为
$$
T_{new}=(1-\alpha)T_{old}+(\alpha T_{old})/k=T_{old}[(1-\alpha)+\alpha/k]
$$
加速比:$S=\frac{T_{old}}{T_{new}}$
$$
S=\frac{1}{(1-\alpha)+\alpha/k}
$$
一个主要部分做出了重大改进,但是获得的系统加速比却明显小于这部分的加速比.这就是Amdahl定律的主要观点-要想显著加速整个系统,必须提升全系统中相当大的部分的速度

### 并发和并行

数字计算机的整个历史中,有两个需求是驱动进步的持续动力:一个是我们想要计算机做得更多,另一个是我们想要计算机运行得更快.当处理器能够同时做更多的事情时,这两个因素都会改进.我们用的术语并发(concurrency)是一个通用的概念,指一个同时具有多个活动的系统;而术语并行( parallelism)指的是用并发来使一个系统运行得更快.并行可以在计算机系统的多个抽象层次上运用.在此,我们按照系统层次结构中由高到低的顺序重点强调三个层次

#### 线程级并发

构建在进程这个抽象之上,我们能够设计出同时有多个程序执行的系统,这就导致了并发.使用线程,我们甚至能够在一个进程中执行多个控制流.自20世纪60年代初期出现时间共享以来,计算机系统中就开始有了对并发执行的支持.传统意义上,这种并发执行只是模拟出来的,是通过使一台计算机在它正在执行的进程间快速切换来实现的.在以前,即使处理器必须在多个任务间切换,大多数实际的计算也都是由一个处理器来完成的.这种配置称为单处理器系统

超线程,有时称为同时多线程(simultaneous multi-threading),是一项允许一个CPU执行多个控制流的技术.它涉及CPU某些硬件有多个备份,比如程序计数器和寄存器文件,而其他的硬件部分只有一份,比如执行浮点算术运算的单元.常规的处理器需要大约20000个时钟周期做不同线程间的转换,而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程.这使得CPU能够更好地利用它的处理资源.

![image-20210628215852587](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210628215852587.png)

多处理器的使用可以从两方面提高系统性能.首先,它减少了在执行多个任务时模拟并发的需要.正如前面提到的,即使是只有一个用户使用的个人计算机也需要并发地执行多个活动.其次,它可以使应用程序运行得更快,当然,这必须要求程序是以多线程方式来书写的,这些线程可以并行地高效执行.因此,虽然并发原理的形成和研究已经超过50年的时间了,但是多核和超线程系统的出现才极大地激发了一种愿望,即找到书写应用程序的方法利用硬件开发线程级并行性.

#### 指令级并行

在较低的抽象层次上,现代处理器可以同时执行多条指令的属性称为指令级并行.

如果处理器可以达到比一个周期一条指令更快的执行速率,就称之为超标量(superscalar)处理器.大多数现代处理器都支持超标量操作

#### 单指令、多数据并行

在最低层次上,许多现代处理器拥有特殊的硬件,允许一条指令产生多个可以并行执行的操作,这种方式称为单指令、多数据,即SIMD并行.

提供这些SIMD指令多是为了提高处理影像、声音和视频数据应用的执行速度.

虽然有些编译器会试图从C程序中自动抽取SIMD并行性,但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序,比如GCC就支持向量数据类型.

### 计算机系统中抽象的重要性

![image-20210628215654641](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210628215654641.png)

抽象的使用是计算机科学中最为重要的概念之一

不同的编程语言提供不同形式和等级的抽象支持.在处理器里,指令集架构提供了对实际处理器硬件的抽象.使用这个抽象,机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上.底层的硬件远比抽象描述的要复杂精细,它并行地执行多条指令,但又总是与那个简单有序的模型保持一致.只要执行模型一样,不同的处理器实现也能执行同样的机器代码,而又提供不同的开销和性能.

# 程序结构和执行

## 信息的表示和处理

现代计算机存储和处理的信息以二值信号表示.这些微不足道的二进制数字,或者称为位(bit),形成了数字革命的基础.使用十进制表示法是很自然的事情,但是当构造存储和处理信息的机器时,二进制值工作得更好.二值信号能够很容易地被表示、存储和传输.

对二值信号进行存储和执行计算的电子电路非常简单和可靠,制造商能够在一个单独的硅片上集成数百万甚至数十亿个这样的电路.

孤立地讲,单个的位不是非常有用.然而,当把位组合在一起,再加上某种解释(interpretation),即赋予不同的可能位模式以含意,我们就能够表示任何有限集合的元素.通过使用标准的字符码,我们能够对文档中的字母和符号进行编码.

我们研究三种最重要的数字表示.无符号(unsigned)编码基于传统的二进制表示法,表示大于或者等于零的数字.补码(two's-complement)编码是表示有符号整数的最常见的方式,有符号整数就是可以为正或者为负的数字.浮点数(floating-point)编码是表示实数的科学记数法的以2为基数的版本.计算机用这些不同的表示方法实现算术运算,例如加法和乘法,类似于对应的整数和实数运算

通过研究数字的实际表示,我们能够了解可以表示的值的范围和不同算术运算的属性.为了使编写的程序能在全部数值范围内正确工作,而且具有可以跨越不同机器、操作系统和编译器组合的可移植性,了解这种属性是非常重要的.后面我们会讲到,大量计算·机的安全漏洞都是由于计算机算术运算的微妙细节引发的.在早期,当人们碰巧触发了程序漏洞,只会给人们带来一些不便,但是现在,有众多的黑客企图利用他们能找到的任何漏洞,不经过授权就进入他人的系统.这就要求程序员有更多的责任和义务,去了解他们的程序如何工作,以及如何被迫产生不良的行为

## 信息存储

大多数计算机使用8位的块,或者字节(byte),作为最小的可寻址的内存单位,而不是访问内存中单独的位.机器级程序将内存视为一个非常大的字节数组,称为虚拟内存(virtual memory),内存的每个字节都由一个唯一的数字来标识,称为它的地址(address),所有可能地址的集合就称为虚拟地址空间(virtual address space).顾名思义,这个虚拟地址空间只是一个展现给机器级程序的概念性映像.实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来,为程序提供一个看上去统一的字节数组.

C编译器还把每个指针和类型信息联系起来,这样就可以根据指针值的类型,生成不同的机器级代码来访问存储在指针所指向位置处的值.尽管C编译器维护着这个类型信息,但是它生成的实际机器级程序并不包含关于数据类型的信息.每个程序对象可以简单地视为一个字节块,而程序本身就是一个字节序列.

> C语言中指针的作用指针是C语言的一个重要特性.它提供了引用数据结构(包括数组)的元素的机制.与变量类似,指针也有两个方面:值和类型.它的值表示某个对象的位置,而它的类型表示那个位置上所存储对象的类型(比如整数或者浮点数)

### 十六进制表示法

一个字节由8位组成.在二进制表示法中,它的值域是$000000_2 \backsim 11111111_2$ 如果看成十进制整数,它的值域就是$0_{10}\backsim255_{10}$.两种符号表示法对于描述位模式来说都不是非常方便.二进制表示法太冗长,而十进制表示法与位模式的互相转化很麻烦.替代的方法是以16为基数,或者叫做十六进制(hexadecimal)数,来表示位模式.

十六进制(简写为"hex")使用数字’0’, ~ ‘9’,以及字符’A’ ~ ‘F’,来表示16个可能的值

在C语言中,以0x或0x开头的数字常量被认为是十六进制的值

### 字数据大小

每台计算机都有一个字长(word size) ,指明指针数据的标称大小(nominal size),因为虚拟地址是以这样的一个字来编码的,所以字长决定的最重要的系统参数就是虚拟地址空间的最大大小.也就是说,对于一个字长为$w$位的机器而言,虚拟地址的范围为$0\backsim2^w-1$,程序最多访问$2^w$个字节

![image-20210629133719075](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210629133719075.png)

为了避免由于依赖“典型”大小和不同编译器设置带来的奇怪行为, ISO C99引入了一类数据类型,其数据大小是固定的,不随编译器和机器设置而变化.其中就有数据类型int32_t和int64_t,它们分别为4个字节和8个字节.使用确定大小的整数类型是程序员准确控制数据表示的最佳途径

程序员应该力图使他们的程序在不同的机器和编译器上可移植.可移植性的一个方面就是使程序对不同数据类型的确切大小不敏感.C语言标准对不同数据类型的数字范围设置了下界,但是却没有上界

### 寻址和字节顺序

对于跨越多字节的程序对象,我们必须建立两个规则:这个对象的地址是什么,以及在内存中如何排列这些字节.在几乎所有的机器上,多字节对象都被存储为连续的字节序列,对象的地址为所使用字节中最小的地址

对于大多数应用程序员来说,其机器所使用的字节顺序是完全不可见的.无论为哪种类型的机器所编译的程序都会得到同样的结果.不过有时候,字节顺序会成为问题.在不同类型的机器之间通过网络传送二进制数据时,一个常见的问题是当小端法机器产生的数据被发送到大端法机器或者反过来时,接收程序会发现,字里的字节成了反序的.为了避免这类问题,网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则,以确保发送方机器将它的内部表示转换成网络标准,而接收方机器则将网络标准转换为它的内部表示

![image-20210629174612714](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210629174612714.png)

对于int类型的数据,除了字节顺序以外,我们在所有机器上都得到相同的结果.特别地,我们可以看到在Linux 32、 Windows和Linux 64上,最低有效字节值0x39最先输出,这说明它们是小端法机器;而在Sun上最后输出,这说明Sun是大端法机器.同样地, float数据的字节,除了字节顺序以外,也都是相同的.另一方面,指针值却是完全不同的.不同的机器/操作系统配置使用不同的存储分配规则.一个值得注意的特性是Linux 32, Windows和Sun的机器使用4字节地址,而Linux 64使用8字节地址

> 使用printf格式化输出
>
> printf函数(还有它的同类fprintf和sprintf)提供了一种打印信息的方式,这种方式对格式化细节有相当大的控制能力.第一个参数是格式串(format string),而其余的参数都是要打印的值.在格式串里,每个以“%”开始的字符序列都表示如何格式化下一个参数

> 文字编码的Unicode标准
>
> ASCII字符集适合于编码英语文档,但是在表达一些特殊字符方面并没有太多办法,例如法语的“Ç".它完全不适合编码希腊语、俄语和中文等语言的文档.这些年提出了很多方法来对不同语言的文字进行编码.Unicode联合会(Unicode Consortium)修订了最全面且广泛接受的文字编码标准.当前的Unicode标准(7.0版)的字库包括将近100000个字符,支持广泛的语言种类,包括古埃及和巴比伦的语言.为了保持信用, Unicode技术委员会否决了为Klingon(即电视连续剧《星际迷航》中的虚构文明)编写语言标准的提议.
>
> 基本编码,称为Unicode的“统一字符集”,使用32位来表示字符.这好像要求文本串中每个字符要占用4个字节.不过,可以有一些替代编码,常见的字符只需要1个或2个字节,而不太常用的字符需要多一些的字节数.特别地, UTF-8表示将每个字符编码为一个字节序列,这样标准ASCII字符还是使用和它们在ASCII中一样的单字节编码,这也就意味着所有的ASCII字节序列用ASCII码表示和用UTF-8表示是一样的.Java编程语言使用Unicode来表示字符串.对于C语言也有支持Unicode的程序库

### 表示代码

我们发现指令编码是不同的.不同的机器类型使用不同的且不兼容的指令和编码方·式.即使是完全一样的进程,运行在不同的操作系统上也会有不同的编码规则,因此二进制代码是不兼容的.二进制代码很少能在不同机器和操作系统组合之间移植

### 布尔代数简介

二进制值是计算机编码、存储和操作信息的核心,所以围绕数值0和1的研究已经演化,出了丰富的数学知识体系.这起源于1850年前后乔治·布尔(George Boole, 1815-1864)的工作,因此也称为布尔代数(Boolean algebra),布尔注意到通过将逻辑值TRUE (真)和FALSE(假)编码为二进制值1和0,能够设计出一种代数,以研究逻辑推理的基本原则

### C语言中的位级运算

C语言的一个很有用的特性就是它支持按位布尔运算.事实上,我们在布尔运算中使用的那些符号就是C语言所使用的:|就是OR(或), &就是AND(与), ~就是NOT(取反),而^就是EXCLUSIVE-OR(异或)

| 逻辑 | 符号 |
| ---- | ---- |
| 或   | \|   |
| 与   | &    |
| 非   | ~    |
| 异或 | ^    |

### c语言中的逻辑运算

C语言还提供了一组逻辑运算符||、 &&和!,分别对应于命题逻辑中的OR,AND和NOT运算.逻辑运算很容易和位级运算相混淆,但是它们的功能是完全不同的

逻辑运算认为所有非零的参数都表示TRUE,而参数0表示FALSE,它们返回1或者0,分别表示结果为TRUE或者为FALSE

逻辑运算符&&和||与它们对应的位级运算&和|之间第二个重要的区别是,如果对第一个参数求值就能确定表达式的结果,那么逻辑运算符就不会对第二个参数求值

### c语言言中的移位运算

C语言还提供了一组移位运算,向左或者向右移动位模式.

有一个相应的右移运算x>>k,但是它的行为有点微妙.一般而言,机器支持两种形式的右移:逻辑右移和算术右移.

![image-20210630111234140](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630111234140.png)

斜体的数字表示的是最右端(左移)或最左端(右移)填充的值.可以看到除了一个条目之外,其他的都包含填充0.唯一的例外是算术右移[10010101]的情况.因为操作数的最高位是1,填充的值就是1

与C相比, Java对于如何进行右移有明确的定义.表达是x>>k会将x算术右移k个位置,而x>>>k会对x做逻辑右移

## 整数表示

![image-20210630111923712](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630111923712.png)

### 整型数据类型

C语言支持多种整型数据类型-表示有限范围的整数.

每种类型都能用关键字来指定大小,这些关键字包括char, short, long,同时还可以指示被表示的数字是非负数(声明为unsigned),或者可能是负数(默认).为这些不同的大小分配的字节数根据程序编译为32位还是64位而有所不同.根据字节分配,不同的大小所能表示的值的范围是不同的

![image-20210630112505381](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630112505381.png)

![image-20210630112519318](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630112519318.png)

![image-20210630144153834](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630144153834.png)

> C、 C++和Java中的有符号和无符号数
>
> C和C++都支持有符号(默认)和无符号数.Java只支持有符号数

### 无符号数的编码

对向量$\vec{x}=[x_{w-1},x_{w-2},\cdots,x_0]:$
$$
B2U_w(\vec x)\approx \sum^{w-1}_{i=0}{x_i2^i}
$$
无符号数的二进制表示有一个很重要的属性,也就是每个介于$0\sim2^n-1$之间的数都·有唯一一个w位的值编码

原理:无符号数编码的唯一性

函数$B2U_w$是一个双射

数学术语双射是指一个函数f有两面:它将数值x映射为数值y,即y=f(x),但它也可以反向操作,因为对每一个y而言,都有唯一一个数值x使得f(x)=y,这可以用反函数$f^{-1}$来表示.函数$B2U_w$将每一个长度为w的位向量都映射为$0\backsim2^n-1$之间的一个唯一值;反过来,我们称其为$U2B_w$(即“无符号数到二进制"),在$0\backsim2^n-1$之间的每一个整数都可以映射为一个唯一的长度为w的位模式

### 补码编码

对于许多应用,我们还希望表示负数值.最常见的有符号数的计算机表示方式就是补码(two' s-complement)形式.在这个定义中,将字的最高有效位解释为负权(negativeweight),我们用函数$B2T_w$(Binary to Two's-complement的缩写,长度为w)来表示

补码编码定义

对向量$\vec x=[x_{w-1},x_{w-2},\cdots,x_0]$
$$
B2T_w(\vec x)\approx -x_{w-1}w^{w-1}+\sum^{w-2}_{i=0}x_iw^i
$$
最高有效位$x_{w-1}$也称为符号位,它的“权重”为$-2^{w-1}$,是无符号表示中权重的负数.符号位被设置为1时,表示值为负,而当设置为0时,值为非负

原理:补码编码的唯一性

函数$B2T_w$是一个双射

我们定义函数$T2B_w$. (即“补码到二进制”)作为$B2T_w$的反函数.也就是说,对于每个数x,满足$TMin_w\leq x\leq TMax_w$,则$T2B_w(x)$是x的(唯一的)w位模式

### 有符号数和无符号数之间的转换

C语言允许在各种不同的数字数据类型之间做强制类型转换.很明显,对于在两种形式中都能表示的值,我们是想要保持不变的.另一方面,将负数转换成无符号数可能会得到0.如果转换的无符号数太大以至于超出了补码能够表示的范围,可能会得到$TMax$,不过,对于大多数C语言的实现来说,对这个问题的回答都是从位级角度来看的,而不是数的角度

对于大多数C语言的实现,处理同样字长的有符号数和无符号数之间相互转换的一般规则是:数值可能会改变,但是位模式不变.让我们用更数学化的形式来描述这个规则.我们定义函数$U2B_w$和$T2B_w$,它们将数值映射为无符号数和补码形式的位表示.也就是说,给定$0\leq x\leq UMax_w$范围内的一个整数x,函数$U2B_w(x)$会给出x的唯一的w位无符号表示.相似地,当满足$TMin_w\leq x\leq TMax_w$,函数$T2B_w(x)$会给出x的唯一的w位补码表示

无符号表示中的UMar有着和补码表示的-1相同的位模式.我们在这两个数之间也能看到这种关系: $1+UMax_w=2^w$

补码转换为无符号数
$$
B2U_w(T2B_w(x))=T2U_w(x)=x+x_{w-1}2^w
$$
当将一个有符号数映射为它相应的无符号数时,负数就被转换成了大的正数,而非负数会保持不变

无符号数转换为补码
$$
U2T_w(u)=-u_{w-1}2^w+u
$$
![image-20210630191321727](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630191321727.png)

### C语言中的有符号数与无符号数

C语言支持所有整型数据类型的有符号和无符号运算.尽管C语言标准没有指定有符号数要采用某种表示,但是几乎所有的机器都使用补码.通常,大多数数字都默认为是有符号的.要创建一个无符号常量,必须加上后缀字符"u'或者'u'

C语言允许无符号数和有符号数之间的转换.虽然C标准没有精确规定应如何进行这种转换,但大多数系统遵循的原则是底层的位表示保持不变.因此,在一台采用补码的机器上,当从无符号数转换为有符号数时,效果就是应用函数$U2T_w$,而从有符号数转换为无符号数时,就是应用函数$T2U_w$,,其中w表示数据类型的位数

### 扩展一个数字的位表示

一个常见的运算是在不同字长的整数之间转换,同时又保持数值不变.当然,当目标数据类型太小以至于不能表示想要的值时,这根本就是不可能的.然而,从一个较小的数据类型转换到一个较大的类型,应该总是可能的

要将一个无符号数转换为一个更大的数据类型,我们只要简单地在表示的开头添加0.这种运算被称为零扩展(zero extension)

无符号数的零扩展

定义宽度为w的位向量$\vec u=[u_{w-1}, u_{w-2},\cdots,u_0]$和宽度为$w'$的位向量$\vec u'=[0,\cdots,0,u_{w-1}, u_{w-2},\cdots,u_o]$,其中$w'>w$.则$B2U_w(\vec u)=B2U_{w'}(\vec u')$

补码数的符号扩展

定义宽度为w的位向量$\vec x=[x_{w-1}, x_{w-2},\cdots,x_0]$和宽度为w的位向量$\vec x'=[x_{w-1},\cdots,x_{w-1},x_{w-1},x_{w-2},\cdots,x_0]$,其中$w'>w$.则$B2U_w(\vec u)=B2U_{w'}(\vec u')$

### 截断数字

原理:截断无符号数

令$\vec x$等于位向量$[x_{w-1}, x_{w-2},\cdots,x_0]$,而$\vec x'$是将其截断为k位的结果:$\vec x'=[x_{k-1},x_{k-2},\cdots,x_0]$.令$x=B2U_w(\vec x)),$ $x'=B2U_k(\vec x')$.则$x'=x mod 2^k$

原理:截断补码数值

令$\vec x$ 等于位向量$[x_{w-1} , x_{w-2},\cdots,x_0]$,而$\vec x'$是将其截断为k位的结果: $\vec x'=[x_{k-1},x_{k-2},\cdots,x_0]$.令$x=B2U_w(\vec x)$,$x'=B2T_k(\vec x')$,则$x'=U2T_k(x mod 2^k)$

### 关于有符号数与符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为.而这些非直观的特性经常导致程序错误,并且这种包含隐式强制类型转换的细微差别的错误很难被发现.因为这种强制类型转换是在代码中没有明确指示的情况下发生的,程序员经常忽视了它的影响

我们已经看到了许多无符号运算的细微特性,尤其是有符号数到无符号数的隐式转换,会导致错误或者漏洞的方式.避免这类错误的一种方法就是绝不使用无符号数.实际上,除了C以外很少有语言支持无符号整数.很明显,这些语言的设计者认为它们带来的麻烦要比益处多得多.比如, Java只支持有符号整数,并且要求以补码运算来实现.正常的右移运算符>>被定义为执行算术右移.特殊的运算符>>>被指定为执行逻辑右移.

## 整数运算

### 无符号加法

![image-20210630210520841](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630210520841.png)

对满足0<x, y<$2^w$的x和y有
$$
x+^u_wy=\begin{cases}
x+y&x+y<2^w\\
x+y-2^w&2^w\leq x+y< 2^{w+1}
\end{cases}
$$
![image-20210630205030100](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630205030100.png)

![image-20210630210540841](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630210540841.png)

​	模数加法形成了一种数学结构,称为阿贝尔群(Abelian group),这是以丹麦数学家Niels Henrik Abel( 1802~1829)的名字命名.也就说,它是可交换的和可结合的.它有一个单位元0,并且每个元素有一个加法逆元

原理:无符号数求反

对满足$0\leq x<2^w$的任意x ,其w位的无符号逆元$-^u_wx$由下式给出
$$
-^u_wx=\begin{cases}x&x=0\\2^w-x&x>0\end{cases}
$$

### 补码加法

对满足$-2^{w-1}\leq x,y\leq 2^{w-1}-1$的整数x和y,有:
$$
x+^t_wy=\begin{cases}
x+y-2^w&w^{w-1}\leq x+y&正溢出\\
x+y&-2^{w-1}\leq x+y<2^{w-1}&正常\\
x+y+2^w&x+y<-w^{w-1}&负溢出
\end{cases}
$$
![image-20210630220606343](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630220606343.png)

![image-20210630221513861](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210630221513861.png)

### 无符号乘法

范围在$0\leq x, y\leq 2^w-1$内的整数x和y可以被表示为w位的无符号数,但是它们的乘积$x\cdot y$的取值范围为0到$(2^w-1)^2=2^{2w}-2^{w+1}+1$之间.这可能需要2w位来表示.不过, C语言中的无符号乘法被定义为产生w位的值,就是2w位的整数乘积的低w位表示的值.我们将这个值表示为$x*^u_wy$

对满足$0\leq x, y\leq UMax_w$的x和y有:
$$
x*^u_wy=(x\cdot y)\mod 2^w
$$

### 补码的非

对满足$TMin_w\leq x\leq TMax_w$的x,其补码的非$-^t_wx$由下式給出
$$
-^t_wx=\begin{cases}TMin_w&x=TMin_w\\-x&x>TMin_w\end{cases}
$$

### 无符号乘法

对满足$0\leq x,y\leq UMax_w$的x和y,有
$$
x*^u_wy=(x\cdot y)\mod 2^w
$$

### 补码乘法

对满足$TMin_w\leq x,y\leq TMax_w$的x和y,有
$$
x*^t_wy=U2T_w((x\cdot y)\mod 2^w)
$$
给定长度为w的位向量$\vec x$和$\vec y$,用补码形式的位向量表示来定义整数x和y:$x=B2T_w(\vec x),y'=B2T_w(\vec y)$.用无符号形式的位向量表示来定义非负整数x'和y':$x'=B2U_w(\vec x),y'=B2U_w(\vec y)$.则
$$
T2B_w(x*^t_wy)=U2B_w(x'*^u_wy')
$$

### 乘以常数

设x为位模式$[x_{w-1},x_{w-2},\cdots,x_0]$表示的无符号整数,那么对于任何$k\geq 0$,我们都认为$[x_{w-1},x_{w-2},\cdots,x_0,0,\cdots,0]$给出了$x2^k$的w+k位的无符号表示,这里的右边增加了k个0

### 除以2的幂

除以2的幂也可以用移位运算来实现,只不过我们用的是右移,而不是左移.无符号和补,码数分别使用逻辑移位和算术移位来达到目的

除以2的幂的无符号除法,C变量x和k有无符号数值x和k,且$0\leq k<w$,则C表达式x>>k产生数值$\lfloor \frac{x}{2^k}\rfloor$

除以2 的幂的补码除法,向下舍入,C变量x和k分别由补码值x和无符号数值k,且$0\leq k<w$,则当执行算术移位时,C表达式x>>k产生数值$\lfloor \frac{x}{2^k}\rfloor$

## 浮点数

大约在1985年,这些情况随着IEEE标准754的推出而改变了,这是一个仔细制订的表示浮点数及其运算的标准.这项工作是从1976年开始由Intel赞助的,与8087的设计同时进行, 8087是一种为8086处理器提供浮点支持的芯片.他们请William Kahan(加州大学伯克利分校的一位教授)作为顾问,帮助设计未来处理器浮点标准.他们支持Kahan加入一个IEEE资助的制订工业标准的委员会.这个委员会最终采纳的标准非常接近于Kahan为Intel设计的标准.目前,实际上所有的计算机都支持这个后来被称为IEEE浮点的标准.这大大提高了科学应用程序在不同机器上的可移植性.

### 二进制小数

十进制表示法
$$
d_md_{m-1}\cdots d_1d_0.d_{-1}d_{-2}\cdots d_{-n}
$$
其中每个十进制数$d_i$的取值范围是0~9,定义为
$$
d=\sum^m_{i=-n}10^i\times d_i
$$
数字权的定义与十进制小数点符号(‘.’)相关,这意味着小数点左边的数字的权是10的正幂,得到整数值,而小数点右边的数字的权是10的负幂,得到小数值

![image-20210701110809239](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210701110809239.png)

### IEЕE 浮点表示

* 符号(sign) s决定这数是负数(s=1)还是正数(s=0),而对于数值0的符号位解释作为特殊情况处理
* 尾数(significand) M是一个二进制小数,它的范围是$1\sim2-\epsilon$ ,或者是$0\sim1-\epsilon$
* 阶码(exponent) E的作用是对浮点数加权,这个权重是2的E次幂(可能是负数)

浮点数的位表示划分为三个字段,分别对这些值进行编码

* 一个单独的符号位s直接编码符号s.
* k位的阶码字段$exp=e_{k-1}\cdots e_1e_0$编码阶码E
* n位小数字段$frac=f_{n-1}\cdots f_1f_0$编码尾数M,但是编码出来的值也依赖于阶码字段的值是否等于0

![image-20210701112955592](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210701112955592.png)

#### 规格化的值

小数字段frac被解释为描述小数值f,其中$0\leq f<1$,其二进制表示为$0,f_{n-1}\cdots f_1f_0$,也就是二进制小数点在最高有效位的左边.尾数定义为M=1+f,有时,这种方式也叫做隐含的以1开头的(implied leading 1)表示,因为我们可以把M看成一个二进制表达式为$1.f_{n-1}f-{n-2}\cdots f_0$的数字.既然我们总是能够调整阶码E,使得尾数M在范围$1\leq M<2$之中(假设没有溢出),那么这种表示方法是一种轻松获得一个额外精度位的技巧.既然第一位总是等于1,那么我们就不需要显式地表示它

#### 非规格化的值

当阶码域为全0时,所表示的数是非规格化形式.在这种情况下,阶码值是E=1-Bias,而尾数的值是M=f,也就是小数字段的值,不包含隐含的开头的1

非规格化数有两个用途.首先,它们提供了一种表示数值0的方法,因为使用规格化数,我们必须总是使M>1,因此我们就不能表示0.实际上, +0.0的浮点表示的位模式为全0:符号位是0,阶码字段全为0(表明是一个非规格化值),而小数域也全为0,这就得到$M=f=0$,令人奇怪的是,当符号位为1,而其他域全为0时,我们得到值-0.0.根据IEEE的浮点格式,值+0.0和-0.0在某些方面被认为是不同的,而在其他方面是相同的

非规格化数的另外一个功能是表示那些非常接近于0.0的数.它们提供了一种属性,称为逐渐溢出(gradual underflow),其中,可能的数值分布均匀地接近于0.0

#### 特殊值

最后一类数值是当指阶码全为1的时候出现的.当小数域全为0时,得到的值表示无穷,当s=0时是十∞,或者当s=1时是-∞.当我们把两个非常大的数相乘,或者除以零时,无穷能够表示溢出的结果.当小数域为非零时,结果值被称为"NaN",即“不是一个数(Not a Number)"的缩写.一些运算的结果不能是实数或无穷,就会返回这样的NaN值,比如当计算$\sqrt{-1}$或∞-∞时

![image-20210701114636423](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210701114636423.png)

### 舍入

因为表示方法限制了浮点数的范围和精度,所以浮点运算只能近似地表示实数运算.因此,对于值x,我们一般想用一种系统的方法,能够找到“最接近的”匹配值x',它可以用期望的浮点形式表示出来.这就是舍入(rounding)运算的任务.一个关键问题是在两个可能值的中间确定舍入方向.一种可选择的方法是维持实际数字的下界和上界.例如,我们可以确定可表示的值$x^-$和$x^+$,使得x的值位于它们之间: $x^-\leq x\leq x^+$.IEEE浮点格式定义了四种不同的舍入方式.默认的方法是找到最接近的匹配,而其他三种可用于计算上界和下界

![image-20210701130727952](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210701130727952.png)

其他三种方式产生实际值的确界(guaranteed bound).向零舍入方式把正数向下舍人,把负数向上舍人,得到值立,使得12<lxl..向下舍入方式把正数和负数都向下舍人,得到值x,,使得x<x.向上舍入方式把正数和负数都向上舍入,得到值xt ,满足x<x

### 浮点运算

IEEE标准中指定浮点运算行为方法的一个优势在于,它可以独立于任何具体的硬件或者软件实现.因此,我们可以检查它的抽象数学属性,而不必考虑它实际上是如何实现的.

实数上的加法也形成了阿贝尔群,但是我们必须考虑舍人对这些属性的影响.我们将$x+^fy$定义为$Round(x+y)$.这个运算的定义针对x和y的所有取值,但是虽然x和y都是实数,由于溢出,该运算可能得到无穷值.对于所有x和y的值,这个运算是可交换的,也就是说$x+^fy=y+^fx$.另一方面,这个运算是不可结合的.作为阿贝尔群,大多数值在浮点加法下都有逆元,也就是说$x+^f-x=0$,无穷(因为+∞-∞=NaN)和NaN是例外情况,因为对于任何x,都有$NaN+^fx=NaN$

### C语言中的浮点数

所有的C语言版本提供了两种不同的浮点数据类型: float和double.在支持IEEE浮点格式的机器上,这些数据类型就对应于单精度和双精度浮点.另外,这类机器使用向偶数舍人的舍入方式.不幸的是,因为C语言标准不要求机器使用IEEE浮点,所以没有标准的方法来改变舍入方式或者得到诸如-0,+∞,-∞或者NaN之类的特殊值

* 从int转换成float,数字不会溢出,但是可能被舍人
* 从int或float转换成double,因为double有更大的范围(也就是可表示值的范围),也有更高的精度(也就是有效位数),所以能够保留精确的数值
* 从double转换成float,因为范围要小一些,所以值可能溢出成+∞或-∞.另外,由于精确度较小,它还可能被舍人
* 以float或者double转换成int,值将会向零舍入

# 程序的机器级表示

计算机执行机器代码,用字节序列编码低级的操作,包括处理数据、管理内存、读写存储设备上的数据,以及利用网络通信.编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例,经过一系列的阶段生成机器代码.GCC C语言编译器以汇编代码的形式产生输出,汇编代码是机器代码的文本表示,给出程序中的每一条指令.然后GCC调用汇编器和链接器,根据汇编代码生成可执行的机器代码.在本章中,我们会近距离地观察机器代码,以及人类可读的表示-汇编代码

即使编译器承担了生成汇编代码的大部分工作,对于严谨的程序员来说,能够阅读和理解汇编代码仍是一项很重要的技能.以适当的命令行选项调用编译器,编译器就会产生一个以汇编代码形式表示的输出文件.通过阅读这些汇编代码,我们能够理解编译器的优化能力,并分析代码中隐含的低效率.试图最大化一段关键代码性能的程序员,通常会尝试源代码的各种形式,每次编译并检查产生的汇编代码,从而了解程序将要运行的效率如何.此外,也有些时候,高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行为.例如,用线程包写并发程序时,了解不同的线程是如何共享程序数据或保持数据私有的,以及准确知道如何在哪里访问共享数据,都是很重要的.这些信息在机器代码级是可见的.另外再举一个例子,程序遭受攻击(使得恶意软件侵扰系统)的许多方式中,都涉及程序存储运行时控制信息的方式的细节.许多攻击利用了系统程序中的漏洞重写信息,从而获得了系统的控制权.了解这些漏洞是如何出现的,以及如何防御它们,需要具备程序机器级表示的知识.程序员学习汇编代码的需求随着时间的推移也发生了变化,开始时要求程序员能直接用汇编语言编写程序,现在则要求他们能够阅读和理解编译器产生的代码.

> 摩尔定律(Moore's Law)
>
> 如果我们画出各种不同的Intel处理器中晶体管的数量与它们出现的年份之间的图(y轴为晶体管数量的对数值),我们能够看出,增长是很显著的.画一条拟合这些数据的线,可以看到晶体管数量以每年大约37%的速率增加,也就是说,晶体管数量每26个月就会翻一番.在x86微处理器的历史上,这种增长已经持续了好几十年.
>
> ![image-20210701172858371](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210701172858371.png)
>
> 1965年, Gordon Moore, Intel公司的创始人,根据当时的芯片技术(那时他们能够在,一个芯片上制造有大约64个晶体管的电路)做出推断,预测在未来10年,芯片上的晶体管数量每年都会翻一番.这个预测就称为摩尔定律.正如事实证明的那样,他的预测有点乐观,而且短视.在超过50年中,半导体工业一直能够使得晶体管数目每18个月翻一倍.

## 程序编码

假设一个C程序,有两个文件p1.c和p2.c.我们用Unix命令行编译这些代码:

```
linux> gcc -Og -S p1.c p2.c
```

命令gcc指的就是GCC C编译器.因为这是Linux上默认的编译器,我们也可以简单地用cc来启动它.编译选项-0g告诉编译器使用会生成符合原始C代码整体结构的机器代码的优化等级.使用较高级别优化产生的代码会严重变形,以至于产生的机器代码和初始源代码之间的关系非常难以理解.因此我们会使用-0g优化作为学习工具,然后当我们增加优化级别时,再看会发生什么.

实际上gcc命令调用了一整套的程序,将源代码转化成可执行代码.首先, C预处理器扩展源代码,插入所有用#include命令指定的文件,并扩展所有用#define声明指定的宏.其次,编译器产生两个源文件的汇编代码,名字分别为p1.s和p2.s,接下来,汇编器会将汇编代码转化成二进制目标代码文件p1.o和p2.0,目标代码是机器代码的一种形式,它包含所有指令的二进制表示,但是还没有填入全局值的地址.最后,链接器将两个目标代码文件与实现库函数(例如printf)的代码合并,并产生最终的可执行代码文件p(由命令行指示符-o p指定的).可执行代码是我们要考虑的机器代码的第二种形式,也就是处理器执行的代码格式.

### 机器级代码

计算机系统使用了多种不同形式的抽象,利用更简单的抽象模型来隐藏实现的细节.对于机器级编程来说,其中两种抽象尤为重要.

第一种是由指令集体系结构或指令集架构(Instruction Set Architecture, ISA)来定义机器级程序的格式和行为,它定义了处理器状态、指令的格式,以及每条指令对状态的影响.大多数ISA,包括x86-64,将程序的行为描述成好像每条指令都是按顺序执行的,一条指令结束后,下一条再开始.处理器的硬件远比描述的精细复杂,它们并发地执行许多指令,但是可以采取措施保证整体行为与ISA指定的顺序执行的行为完全一致.

第二种抽象是,机器级程序使用的内存地址是虚拟地址,提供的内存模型看上去是一个非常大的字节数组.存储器系统的实际实现是将多个硬件存储器和操作系统软件组合起来.

在整个编译过程中,编译器会完成大部分的工作,将把用C语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令.汇编代码表示非常接近于机器代码.与机器代码的二进制格式相比,汇编代码的主要特点是它用可读性更好的文本格式表示.能够理解汇编代码以及它与原始C代码的联系,是理解计算机如何执行程序的关键一步.

x86-64的机器代码和原始的C代码差别非常大.一些通常对C语言程序员隐藏的处理器状态都是可见的

* 程序计数器(通常称为"PC",在x86-64中用%rip表示)给出将要执行的下一条指令在内存中的地址
* 整数寄存器文件包含16个命名的位置,分别存储64位的值.这些寄存器可以存储地址(对应于C语言的指针)或整数数据.有的寄存器被用来记录某些重要的程序状态,而其他的寄存器用来保存临时数据,例如过程的参数和局部变量,以及函数的返回值
* 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息.它们用来实现控制或数据流中的条件变化,比如说用来实现if和while语句
* 一组向量寄存器可以存放一个或多个整数或浮点数值

程序内存包含:程序的可执行机器代码,操作系统需要的一些信息,用来管理过程调用和返回的运行时栈,以及用户分配的内存块(比如说用malloc库函数分配的).正如前面提到的,程序内存用虚拟地址来寻址.在任意给定的时刻,只有有限的一部分虚拟地址被认为是合法的.在目前的实现中,这些地址的高16位必须设置为0,所以一个地址实际上能够指定的是$2^{48}$或$64TB$范围内的一个字节.较为典型的程序只会访问几兆字节或几千兆字节的数据.操作系统负责管理虚拟地址空间,将虚拟地址翻译成实际处理器内存中的物理地址

一条机器指令只执行一个非常基本的操作

#### 产生汇编代码

```
linux> gcc -Og -S mstore.c
```

这会使GCC运行编译器,产生一个汇编文件mstore.s,但是不做其他进一步的工作.(通常情况下,它还会继续调用汇编器产生目标代码文件)

```
linux> gcc -Og -c mstore.c
```

这就会产生目标代码文件mstore.o,它是二进制格式的,所以无法直接查看

#### 产生机器代码

要查看机器代码文件的内容,有一类称为反汇编器(disassembler)的程序非常有用.这些程序根据机器代码产生一种类似于汇编代码的格式.在Linux系统中,带‘-d’命令行标志的程序OBJDUMP(表示"object dump")可以充当这个角色

```
linux> objdump -d mstore.o
```

其中一些关于机器代码和它的反汇编表示的特性值得注意:

* x86-64的指令长度从1到15个字节不等.常用的指令以及操作数较少的指令所需的字节数少,而那些不太常用或操作数较多的指令所需字节数较多
* 设计指令格式的方式是,从某个给定位置开始,可以将字节唯一地解码成机器指令
* 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码.它不需要访问该程序的源代码或汇编代码
* 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别

### 关于格式的注解

所有以‘.’开头的行都是指导汇编器和链接器工作的伪指令.我们通常可以忽略这些行.另一方面,也没有关于指令的用途以及它们与源代码之间关系的解释说明

通常我们只会给出与讨论内容相关的代码行.每一行的左边都有编号供引用,右边是·注释,简单地描述指令的效果以及它与原始C语言代码中的计算操作的关系.这是一种汇编语言程序员写代码的风格

> 把C程序和汇编代码结合起来
>
> 虽然C编译器在把程序中表达的计算转换到机器代码方面表现出色,但是仍然有一些机器特性是C程序访问不到的.例如,每次x86-64处理器执行算术或逻辑运算时,如果得到的运算结果的低8位中有偶数个1,那么就会把一个名为PF的1位条件码(condition code)标志设置为1,否则就设置为0.这里的PF表示"parity flag(奇偶标志)”.在C语言中计算这个信息需要至少7次移位、掩码和异或运算.即使作为每次算术或逻辑运算的一部分,硬件都完成了这项计算,而C程序却无法知道PF条件码标志的值.在程序中插入几条汇编代码指令就能很容易地完成这项任务
>
> 在C程序中插入汇编代码有两种方法.第一种是,我们可以编写完整的函数,放进一个独立的汇編代码文件中,让汇编器和链接器把它和用C语言书写的代码合并起来.第二种方法是,我们可以使用GCC的内联汇编(inline assembly)特性,用asm伪指令可以在C程序中包含简短的汇編代码.这种方法的好处是减少了与机器相关的代码量
>
> 当然,在C程序中包含汇编代码使得这些代码与某类特殊的机器相关(例如x8664),所以只应该在想要的特性只能以此种方式才能访问到时才使用它

## 访问信息

一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用目的寄存器.这些寄存器用来存储整数数据和指针.它们的名字都以%r开头,不过后面还跟着一些不同的命名规则的名字,这是由于指令集历史演化造成的.最初的8086中有8个16位的寄存器,即%ax到%bp.每个寄存器都有特殊的用途,它们的名字就反映了这些不同的用途.扩展到1A32架构时,这些寄存器也扩展成32位寄存器,标号从%eax到%ebp.扩展到x86-64后,原来的8个寄存器扩展成64位,标号从%rax到%rbp.除此之外,还增加了8个新的寄存器,它们的标号是按照新的命名规则制定的:从%r8到%r15

![image-20210701185529579](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210701185529579.png)

字节级操作可以访问最低的字节, 16位操作可以访问最低的2个字节, 32位操作可以访问最低的4个字节,而64位操作可以访问整个寄存器

### 操作数指示符

大多数指令有一个或多个操作数(operand),指示出执行一个操作中要使用的源数据值,以及放置结果的目的位置.x86-64支持多种操作数格式,源数据值可以以常数形式给出,或是从寄存器或内存中读出.结果可以存放在寄存器或内存中.因此,各种不同的操作数的可能性被分为三种类型.

* 第一种类型是立即数(immediate),用来表示常数值.在ATT格式的汇编代码中,立即数的书写方式是'$'后面跟一个用标准C表示法表示的整数,不同的指令允许的立即数值范围不同,汇编器会自动选择最紧凑的方式进行数值编码.
* 第二种类型是寄存器(register),它表示某个寄存器的内容, 16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数,这些字节数分别对应于8位、16位、32位或64位.我们用符号$a_r$来表示任意寄存器a,用引用$R[r_a]$来表示它的值,这是将寄存器集合看成一个数组R,用寄存器标识符作为索引
* 第三类操作数是内存引用,它会根据计算出来的地址(通常称为有效地址)访问某个内存位置.因为将内存看成一个很大的字节数组,我们用符号$M_b[Addr]$表示对存储在内存中从地址Addr开始的b个字节值的引用.为了简便,我们通常省去下标b.有多种不同的寻址模式,允许不同形式的内存引用

![image-20210702093923106](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702093923106.png)

### 数据传送指令

最频繁使用的指令是将数据从一个位置复制到另一个位置的指令.操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能

![image-20210702094215997](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702094215997.png)

* 常规的movq指令只能以表示为32位补码数字的立即数作为源操作数,然后把这个值符号扩展得到64位的值,放到目的位置
* movabsq指令能够以任意64位立即数值作为源操作数,并且只能以寄存器作为目的

![image-20210702100506383](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702100506383.png)

![image-20210702100725655](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702100725655.png)

### 压入和弹出栈数据

![image-20210702103456581](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702103456581.png)

栈是一种数据结构,可以添加或者删除值,不过要遵循“后进先出”的原则.通过push操作把数据压入栈中,通过pop操作删除数据;它具有一个属性:弹出的值永远是最近被压入而且仍然在栈中的值.栈可以实现为一个数组,总是从数组的一端插入和删除元素.这一端被称为栈页.在x86-64中,程序栈存放在内存中某个区域.栈向下增长,这样一来,栈顶元素的地址是所有栈中元素地址中最低的.(根据惯例,我们的栈是倒过来画的,栈“顶”在图的底部.)栈指针 rsp保存着栈顶元素的地址.

![image-20210702103745192](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702103745192.png)

pushq指令的功能是把数据压人到栈上,而popq指令是弹出数据.这些指令都只有一个操作数-压入的数据源和弹出的数据目的

* 将一个四字值压人栈中,首先要将栈指针减8,然后将值写到新的栈顶地址.因此,指令pushq grbp的行为等价于下面两条指令:

  ```
  subq $8,%rsp
  movq %rbp,(%rsp)
  ```

* 弹出一个四字的操作包括从栈顶位置读出数据,然后将栈指针加8,因此,指令popq %rax等价于下面两条指令

  ```
  movq (%rsp),%rax
  addq $8,%rsp
  ```

## 算术和逻辑操作

![image-20210702122002982](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702122002982.png)

### 加载有效地址

加载有效地址(load effective address)指令leaq实际上是movq指令的变形.它的指令形式是从内存读数据到寄存器,但实际上它根本就没有引用内存.它的第一个操作数看上去是一个内存引用,但该指令并不是从指定的位置读入数据,而是将有效地址写入到目的操作数

### 一元和二元操作

第二组中的操作是一元操作,只有一个操作数,既是源又是目的.这个操作数可以是一个寄存器,也可以是一个内存位置.

第三组是二元操作,其中,第二个操作数既是源又是目的.源操作数是第一个, 目的操作数是第二个,对于不可交换操作来说,这看上去很奇特.第一个操作数可以是立即数、寄存器或是内存位置.第二个操作数可以是寄存器或是内存位置.注意,当第二个操作数为内存地址时,处理器必须从内存读出值,执行操作,再把结果写回内存

### 移位操作

最后一组是移位操作,先给出移位量,然后第二项给出的是要移位的数.可以进行算术和逻辑右移.移位量可以是一个立即数,或者放在单字节寄存器%cl中.(这些指令很特别,因为只允许以这个特定的寄存器作为操作数.)原则上来说, 1个字节的移位量使得移位量的编码范围可以达到$2^8-1=255$, x86-64中,移位操作对w位长的数据值进行操作,移位量是由%cl寄存器的低m位决定的,这里$2^m=w$,高位会被忽略

### 特殊的算术操作

![image-20210702130831056](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702130831056.png)

两个64位有符号或无符号整数相乘得到的乘积需要128位来表示.x86-64指令集对128位(16字节)数的操作提供有限的支持.延续字(2字节)、双字(4字节)和四字(8字节)的命名惯例, Intel把16字节的数称为八字(oct word)

imulq指令有两种不同的形式.其中一种,是一个“双操作数”乘法指令.它从两个64位操作数产生一个64位乘积

此外, x86-64指令集还提供了两条不同的“单操作数”乘法指令,以计算两个64位值的全128位乘积-一个是无符号数乘法(mulq),而另一个是补码乘法(imulq).这两条指令都要求一个参数必须在寄存器 %rax中,而另一个作为指令的源操作数给出.然后乘积存放在寄存器%rdx(高64位)和%rax(低64位)中.虽然imulq这个名字可以用于两个不同的乘法操作,但是汇编器能够通过计算操作数的数目,分辨出想用哪条指令

有符号除法指令idivl将寄存器%rdx(高64位)和%rax(低64位)中的128位数作为被除数,而除数作为指令的操作数给出.指令将商存储在寄存器%rax中,将余数存储在寄存器%rdx中.

对于大多数64位除法应用来说,除数也常常是一个64位的值.这个值应该存放在%rax中,%rdx的位应该设置为全0(无符号运算)或者%rax的符号位(有符号运算).后面这个操作可以用指令cqto来完成.这条指令不需要操作数–它隐含读出%rax的符号位,并将它复制到%rdx的所有位

## 控制

到目前为止,我们只考虑了直线代码的行为,也就是指令一条接着一条顺序地执行.C语言中的某些结构,比如条件语句、循环语句和分支语句,要求有条件的执行,根据数据测试的结果来决定操作执行的顺序.机器代码提供两种基本的低级机制来实现有条件的行为:测试数据值,然后根据测试的结果来改变控制流或者数据流.与数据相关的控制流是实现有条件行为的更一般和更常见的方法,所以我们先来介绍它.通常, C语言中的语句和机器代码中的指令都是按照它们在程序中出现的次序,顺序执行的.用jump指令可以改变一组机器代码指令的执行顺序, jump指令指定控制应该被传递到程序的某个其他部分,可能是依赖于某个测试的结果.编译器必须产生构建在这种低级机制基础之上的指令序列,来实现C语言的控制结构

### 条件码

除了整数寄存器, CPU还维护着一组单个位的条件码(condition code)寄存器,它们描述了最近的算术或逻辑操作的属性.可以检测这些寄存器来执行条件分支指令.最常用的条件码有:

CF:进位标志.最近的操作使最高位产生了进位.可用来检查无符号操作的溢出

ZF:零标志.最近的操作得出的结果为0

SF:符号标志.最近的操作得到的结果为负数

OF:溢出标志.最近的操作导致一个补码溢出–正溢出或负溢出

![image-20210702141320634](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702141320634.png)

CMP指令根据两个操作数之差来设置条件码.除了只设置条件码而不更新目的寄存器之外, CMP指令与SUB指令的行为是一样的.在ATT格式中,列出操作数的顺序是相反的,这使代码有点难读.如果两个操作数相等,这些指令会将零标志设置为1,而其他的标志可以用来确定两个操作数之间的大小关系.TEST指令的行为与AND指令一样,除了它们只设置条件码而不改变目的寄存器的值

### 访问条件码

条件码通常不会直接读取,常用的使用方法有三种: 

* 可以根据条件码的某种组合,将一个字节设置为0或者1
* 可以条件跳转到程序的某个其他的部分
* 可以有条件地传送数据

对于第一种情况,指令根据条件码的某种组合,将一个字节设置为0或者1.我们将这一整类指令称为SET指令;它们之间的区别就在于它们考虑的条件码的组合是什么,这些指令名字的不同后缀指明了它们所考虑的条件码的组合.这些指令的后缀表示不同的条件而不是操作数大小,了解这一点很重要.

一条SET指令的目的操作数是低位单字节寄存器元素之一,或是一个字节的内存位置,指令会将这个字节设置成0或者1.为了得到一个32位或64位结果,我们必须对高位清零

![image-20210702163831314](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702163831314.png)

某些底层的机器指令可能有多个名字,我们称之为“同义名(synonym)".比如说,setg(表示“设置大于”)和setnle(表示“设置不小于等于”)指的就是同一条机器指令.编译器和反汇编器会随意决定使用哪个名字

虽然所有的算术和逻辑操作都会设置条件码,但是各个SET命令的描述都适用的情况是:执行比较指令

注意到机器代码如何区分有符号和无符号值是很重要的.同C语言不同,机器代码不会将每个程序值都和一个数据类型联系起来.相反,大多数情况下,机器代码对于有符号和无符号两种情况都使用一样的指令,这是因为许多算术运算对无符号和补码算术都有一样的位级行为.有些情况需要用不同的指令来处理有符号和无符号操作

### 跳转指令

正常执行的情况下,指令按照它们出现的顺序一条一条地执行.跳转(jump)指令会导致执行切换到程序中一个全新的位置.在汇编代码中,这些跳转的目的地通常用一个标号(label)指明

![image-20210702170643773](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702170643773.png)

### 跳转指令的编码

在汇编代码中,跳转目标用符号标号书写.汇编器以及后来的链接器,会产生跳转目标的适当编码.跳转指令有,几种不同的编码,但是最常用都是PC相对的(PCrelative),也就是,它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码.这些地址偏移量可以编码为1、2或4个字节.第二种编码方法是给出“绝对”地址,用4个字节直接指定目标.汇编器和链接器会选择适当的跳转目的编码

### 用条件控制来实现条件分支

![image-20210702174242793](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702174242793.png)

将条件表达式和语句从C语言翻译成机器代码,最常用的方式是结合有条件和无条件跳转

### 用条件传送来实现条件分支

实现条件操作的传统方法是通过使用控制的条件转移.当条件满足时,程序沿着一条执行路径执行,而当条件不满足时,就走另一条路径.这种机制简单而通用,但是在现代处理器上,它可能会非常低效.

一种替代的策略是使用数据的条件转移.这种方法计算一个条件操作的两种结果,然后再根据条件是否满足从中选取一个.只有在一些受限制的情况中,这种策略才可行,但是如果可行,就可以用一条简单的条件传送指令来实现它,条件传送指令更符合现代处理器的性能特性

![image-20210702174216601](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702174216601.png)

为了理解为什么基于条件数据传送的代码会比基于条件控制转移的代码性能要好,我们必须了解一些关于现代处理器如何运行的知识.处理器通过使用流水线(pipelining)来获得高性能,在流水线中,条指令的处理要经过一系列的阶段,每个阶段执行所需操作的一小部分(例如,从内存取指令、确定指令类型、从内存读数据、执行算术运算、向内存写数据,以及更新程序计数器).这种方法通过重叠连续指令的步骤来获得高性能.要做到这一点,要求能够事先确定要执行的指令序列,这样才能保持流水线中充满了待执行的指令.当机器遇到条件跳转(也称为“分支”)时,只有当分支条件求值完成之后,才能决定分支往哪边走.处理器采用非常精密的分支预测逻辑来猜测每条跳转指令是否会执行.只要它的猜测还比较可靠(现代微处理器设计试图达到90%以上的成功率),指令流水线中就会充满着指令.另一方面,错误预测一个跳转,,要求处理器丢掉它为该跳转指令后所有指令已做的工作,然后再开始用从正确位置处起始的指令去填充流水线.正如我们会看到的,这样一个错误预测会招致很严重的惩罚,浪费大约15~30个时钟周期,导致程序性能严重下降

![image-20210702174549253](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702174549253.png)

同条件跳转不同,处理器无需预测测试的结果就可以执行条件传送.处理器只是读源"值(可能是从内存中),检查条件码,然后要么更新目的寄存器,要么保持不变

使用条件传送也不总是会提高代码的效率.编译器必须考虑浪费的计算和由于分支预测错误所造成的性能处罚之间的相对性能.说实话,编译器并不具有足够的信息来做出可靠的决定;例如,它们不知道分支会多好地遵循可预测的模式.我们对GCC的实验表明,只有当两个表达式都很容易计算时.根据我们的经验,即使许多分支预测错误的开销会超过更复杂的计算, GCC还是会使用条件控制转移.所以,总的来说,条件数据传送提供了一种用条件控制转移来实现条件操作的替代策略.它们只能用于非常受限制的情况,但是这些情况还是相当常见的,而且与现代处理器的运行方式更契合

### 循环

C语言提供了多种循环结构,即do-while, while和for,汇编中没有相应的指令存在,可以用条件测试和跳转组合起来实现循环的效果.GCC和其他汇编器产生的循环代码主要基于两种基本的循环模式.我们会循序渐进地研究循环的翻译,从do-while开始,然后再研究具有更复杂实现的循环,并覆盖这两种模式

#### do-while循环

通用形式

```cpp
do
    body-statemant
    while(test-expr);
```

这个循环的效果就是重复执行body-statement,对testexpr求值,如果求值的结果为非零,就继续循环.可以看到, body-statement至少会执行一次

![image-20210702194251604](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702194251604.png)



> 逆向工程循环
>
> 理解产生的汇编代码与原始源代码之间的关系,关键是找到程序值和寄存器之间的映射关系.对对于更复杂的程序来说,就可能是更具挑战性的任务.C语言编译器常常会重组计算, 因此有些C代码中的变量在机器代码中没有对应的值;而有时,机器代码中又会引入源代码中不存在的新值.此外,编译器还常常试图将多个程序值映射到一个寄存器上,来最小化寄存器的使用率

#### while循环

通用形式如下

```cpp
while(test-expr)
    body-statement
```

与do-while的不同之处在于,在第一次执行body-statement之前,它会对test-expr求值,循环有可能就中止了.有很多种方法将while循环翻译成机器代码, GCC在代码生成中使用其中的两种方法.这两种方法使用同样的循环结构,与do-while一样,不过它"们实现初始测试的方法不同.第一种翻译方法,我们称之为跳转到中间(jump to middle),它执行一个无条件跳转跳到循环结尾处的测试,以此来执行初始的测试

```c++
	goto test;
loop:
	body-statement
test:
	t=test-expr;
	if(t)
    goto loop;
```

![image-20210702195331505](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210702195331505.png)

#### for循环

通用形式如下:

```cpp
for(init-expr;test-expr;update-expr)
    body-statement
```

与while相似

```cpp
init-expr;
while(test-expr){
    body-statement
    update-expr;
}
```

#### switch语句

switch(开关)语句可以根据一个整数索引值进行多重分支(multiway branching).在处理具有多种可能结果的测试时,这种语句特别有用.它们不仅提高了C代码的可读性,而且通过使用跳转表(jump table)这种数据结构使得实现更加高效.跳转表是一个数组,表项i是一个代码段的地址,这个代码段实现当开关索引值等于i时程序应该采取的动作.程序代码用开关索引值来执行一个跳转表内的数组引用,确定跳转指令的目标.和使用组很长的if-else语句相比,使用跳转表的优点是执行开关语句的时间与开关情况的数量无关.GCC根据开关情况的数量和开关情况值的稀疏程度来翻译开关语句.当开关情况数量比较多(例如4个以上),并且值的范围跨度比较小时,就会使用跳转表

执行switch语句的关键步骤是通过跳转表来访问代码位置. GCC支持计算goto(computed goto),是对C语言的扩展.

## 过程

过程是软件中一种很重要的抽象.它提供了一种封装代码的方式,用一组指定的参数和一个可选的返回值实现了某种功能.然后,可以在程序中不同的地方调用这个函数.设计良好的软件用过程作为抽象机制,隐藏某个行为的具体实现,同时又提供清晰简洁的接口定义,说明要计算的是哪些值,过程会对程序状态产生什么样的影响.不同编程语言中,过程的形式多样:函数(function)、方法(method)、子例程(subroutine)、处理函数(handler)等等,但是它们有一些共有的特性

要提供对过程的机器级支持,必须要处理许多不同的属性.为了讨论方便,假设过程P调用过程Q, Q执行后返回到P.这些动作包括下面一个或多个机制:

* 传递控制.在进入过程Q的时候,程序计数器必须被设置为Q的代码的起始地址,然后在返回时,要把程序计数器设置为P中调用Q后面那条指令的地址
* 传递数据.P必须能够向Q提供一个或多个参数, Q必须能够向P返回一个值
* 分配和释放内存.在开始时, Q可能需要为局部变量分配空间,而在返回前,又必须释放这些存储空间

x86-64的过程实现包括一组特殊的指令和一些对机器资源(例如寄存器和程序内存)使用的约定规则.人们花了大量的力气来尽量减少过程调用的开销.所以,它遵循了被认为是最低要求策略的方法,只实现上述机制中每个过程所必需的那些

### 运行时栈

![image-20210703103132251](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210703103132251.png)

C语言过程调用机制的一个关键特性(大多数其他语言也是如此)在于使用了栈数据结构提供的后进先出的内存管理原则.在过程P调用过程Q的例子中,可以看到当Q在执行时, P以及所有在向上追溯到P的调用链中的过程,都是暂时被挂起的.当Q运行时,它只需要为局部变量分配,新的存储空间,或者设置到另一个过程的调用.另一方面,当Q返回时,任何它所分配的局部存储空间都可以被释放.因此,程序可以用栈来管理它的过程所需要的存储空间,栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息.当P调用Q时,控制和数据信息添加到栈尾.当P返回时,这些信息会释放掉

### 转移控制

将控制从函数P转移到函数Q只需要简单地把程序计数器(PC)设置为Q的代码的起始位置.不过,当稍后从Q返回的时候,处理器必须记录好它需要继续P的执行的代码位置.在86-64机器中,这个信息是用指令call Q调用过程Q来记录的.该指令会把地址A压入栈中,并将PC设置为Q的起始地址.压人的地址A被称为返回地址,是紧跟在call指令后面的那条指令的地址

![image-20210703104503636](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210703104503636.png)

### 数据传送

当调用一个过程时,除了要把控制传递给它并在过程返回时再传递回来之外,过程调用还可能包括把数据作为参数传递,而从过程返回还有可能包括返回一个值.x86-64中,大部分过程间的数据传送是通过寄存器实现的.例如,我们已经看到无数的函数示例,参数在寄存器%rdi,%rsi和其他寄存器中传递.当过程P调用过程Q时, P的代码必须首先把参数复制到适当的寄存器中.类似地,当Q返回到P时, P的代码可以访问寄存器号%rax中的返回值

x86-64中,可以通过寄存器最多传递6个整型(例如整数和指针)参数.寄存器的使用是有特殊顺序的,寄存器使用的名字取决于要传递的数据类型的大小.会根据参数在参数列表中的顺序为它们分配寄存器.可以通过64位寄存器适当的部分访问小于64位的参数

![image-20210703105434297](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210703105434297.png)

![image-20210703110155347](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210703110155347.png)

我们可以看到根据操作数的大小,使用了ADD指令的不同版本: al(long)使用addq,a2(int)使用addl, a3(short)使用addw,而a4(char)使用addb

### 栈上的局部存储

到目前为止我们看到的大多数过程示例都不需要超出寄存器大小的本地存储区域.不过有些时候,局部数据必须存放在内存中,常见的情况包括:

* 寄存器不足够存放所有的本地数据
* 对一个局部变量使用地址运算符'&',因此必须能够为它产生一个地址
* 某些局部变量是数组或结构,因此必须能够通过数组或结构引用被访问到

一般来说,过程通过减小栈指针在栈上分配空间.分配的结果作为栈帧的一部分,标号为“局部变量”

### 寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源.虽然在给定时刻只有一个过程是活动的,我们仍然必须确保当一个过程(调用者)调用另一个过程(被调用者)时,被调用者不会覆盖调用者稍后会使用的寄存器值.为此, x86-64采用了一组统一的寄存器使用惯例,所有的过程(包括程序库)都必须遵循

根据惯例,寄存器号%rbx,&rbp和%r12~%r15被划分为被调用者保存寄存器.当过程P调用过程Q时, Q必须保存这些寄存器的值,保证它们的值在Q返回到P时与Q被调用时是一样的.过程Q保存一个寄存器的值不变,要么就是根本不去改变它,要么就是把原始值压入栈中,改变寄存器的值,然后在返回前从栈中弹出旧值.压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分.有了这条惯例, P的代码就能安全地把值存在被调用者保存寄存器中(当然,要先把之前的值保存到栈上),调用Q,然后继续使用寄存器中的值,不用担心值被破坏

所有其他的寄存器,除了栈指针&rsp,都分类为调用者保存寄存器.这就意味着任何函数都能修改它们.可以这样来理解“调用者保存”这个名字:过程P在某个此类寄存器中有局部数据,然后调用过程Q.因为Q可以随意修改这个寄存器,所以在调用之前首先保存好这个数据是P(调用者)的责任

## 数组分配和访问

C语言中的数组是一种将标量数据聚集成更大数据类型的方式.C语言实现数组的方式非常简单,因此很容易翻译成机器代码.C语言的一个不同寻常的特点是可以产生指向数组中元素的指针,并对这些指针进行运算.在机器代码中,这些指针会被翻译成地址计算.优化编译器非常善于简化数组索引所使用的地址计算.不过这使得C代码和它到机器代码的翻译之间的对应关系有些难以理解

### 基本原则

对于数据类型T和整型常数N,声明如下

```c
T A[N];
```

起始位置表示为$x_A$.这个声明有两个效果.首先,它在内存中分配一个$L\cdot N$字节的连续区域,这里L是数据类型 的大小(单位为字节).其次,它引入了标识符A,可以用A来作为指向数组开头的指针,这个指针的值就是$x_A$.可以用0~N-1的整数索引来访问该数组元素.数组元素i会被存放在地址为$x_A+L\cdot i$的地方

### 指针运算

C语言允许对指针进行运算,而计算出来的值会根据该指针引用的数据类型的大小进·行伸缩.也就是说,如果p是一个指向类型为T的数据的指针, p的值为x,那么表达式$p+i$的值为$x_p+L\cdot i$,这里1是数据类型T的大小

单操作数操作符‘&’,和“*” ,可以产生指针和间接引用指针.对于一个表示某个对象的表达式Expr, &Expr是给出该对象地址的一个指针.对于一个表示地址的表达式AExpr, *AExpr给出该地址处的值.因此,表达式Expr与 *&Expr是等价的.可以对数组和指针应用数组下标操作.数组引用A[i]等同于表达式 *(A+ i).它计算第i个数组元素的地址,然后访问这个内存位置

### 嵌套的数组

![image-20210704084935284](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210704084935284.png)

要访问多维数组的元素,编译器会以数组起始为基地址,(可能需要经过伸缩的)偏移量为索引,产生计算期望的元素的偏移量,然后使用某种MOV指令.通常来说,对于一个,声明如下的数组:

```C
T D[R][C];
```

它的数组元素D[i] [j]的内存地址为

```C
&D[i][j]=xo+L(C·i+j)
```

### 定长数组

当程序要用一个常数作为数组的维度或者缓冲区的大小时,最好通过#define声明将这个常数与一个名字联系起来,然后在后面一直使用这个名字代替常数的数值.这样一来,如果需要修改这个值,只用简单地修改这个#define声明就可以了

### 变长数组

在变长数组的C版本中,我们可以将一个数组声明如下:

```c
int A [expr1][expr2]
```

它可以作为一个局部变量,也可以作为一个函数的参数,然后在遇到这个声明的时候,通过对表达式expr1和expr2求值来确定数组的维度.

```c
int var_ele(long n, int A[n][n] , long i, long j) {
    return A[i][j];
}
```

## 异质的数据结构

```mermaid
graph TD
异质数据结构-->结构体
异质数据结构-->联合体
```



C语言提供了两种将不同类型的对象组合到一起创建数据类型的机制:结构(structure),用关键字struct来声明,将多个对象集合到一个单位中;联合(union),用关键字union来声明,允许用几种不同的类型来引用一个对象

### 结构

C语言的struct声明创建一个数据类型,将可能不同类型的对象聚合到一个对象中.用名字来引用结构的各个组成部分.类似于数组的实现,结构的所有组成部分都存放在内存中一段连续的区域内,而指向结构的指针就是结构第一个字节的地址.编译器维护关于每个结构类型的信息,指示每个字段(field)的字节偏移.它以这些偏移作为内存引用指令中的位移,从而产生对结构元素的引用

为了访问结构的字段,编译器产生的代码要将结构的地址加上适当的偏移

### 联合

联合提供了一种方式,能够规避C语言的类型系统,允许以多种类型来引用一个对象.联合声明的语法与结构的语法一样,只不过语义相差比较大.它们是用不同的字段来引用相同的内存块

在一些下上文中,联合十分有用.但是,它也能引起一些讨厌的错误,因为它们绕过了C语言类型系统提供的安全措施.一种应用情况是,我们事先知道对一个数据结构中的两个不同字段的使用是互斥的,那么将这两个字段声明为联合的一部分,而不是结构的一部分,会减小分配空间的总量

联合还可以用来访问不同数据类型的位模式

当用联合来将各种不同大小的数据类型结合到一起时,字节顾序问题就变得很重要了

### 数据对齐

许多计算机系统对基本数据类型的合法地址做出了一些限制,要求某种类型对象的地址必须是某个值K(通常是2、4或8)的倍数.这种对齐限制简化了形成处理器和内存系统之间接口的硬件设计

无论数据是否对齐, x86-64硬件都能正确工作.不过, Intel还是建议要对齐数据以提高内存系统的性能.对齐原则是任何K字节的基本对象的地址必须是K的倍数

确保每种数据类型都是按照指定方式来组织和分配,即每种类型的对象都满足它的对齐限制,就可保证实施对齐.编译器在汇编代码中放入命令,指明全局数据所需的对齐

对于包含结构的代码,编译器可能需要在字段的分配中插入间隙,以保证每个结构元素都满足它的对齐要求.而结构本身对它的起始地址也有一些对齐要求

另外,编译器结构的未尾可能需要一些填充,这样结构数组中的每个元素都会满足它的对齐要求

| 数据类型          | 16位字节 | 32位字节 | 64位字节 |
| ----------------- | -------- | -------- | -------- |
| bite              | 1        | 1        | 1        |
| char              | 1        | 1        | 1        |
| short             | 2        | 2        | 2        |
| int(unsigned int) | 2        | 4        | 4        |
| float             | 4        | 4        | 4        |
| double            | 8        | 8        | 8        |
| long              | 4        | 4        | 8        |
| unsigned long     | 4        | 4        | 8        |
| long long         | 8        | 8        | 8        |

> 强制对齐的情况
>
> 对于大多数x86-64指令来说,保持数据对齐能够提高效率,但是它不会影响程序的行为.另一方面,如果数据没有对齐,某些型号的Intel和AMD处理器对于有些实现多媒体操作的SSE指令,就无法正确执行.这些指令对16字节数据块进行操作,在SSE单元和内存之间传送数据的指令要求内存地址必须是16的倍数.任何试图以不满足对齐要求的地址来访问内存都会导致异常,默认的行为是程序终止
>
> 因此,任何针对x86-64处理器的编译器和运行时系统都必须保证分配用来保存可能会被SSE寄存器读或写的数据结构的内存,都必须满足16字节对齐.这个要求有两个后果:·
>
> * 任何内存分配函数(alloca, malloc, calloc或realloc)生成的块的起始地址都必须是16的倍数
> * 大多数函数的栈帧的边界都必须是16字节的倍数
>
> 较近版本的x86-64处理器实现了AVX多媒体指令.除了提供SSE指令的超集,支持AVX的指令并没有强制性的对齐要求

## 在机器级程序中将控制与数据结合起来

### 理解指针

指针是C语言的一个核心特色.它们以一种统一方式,对不同数据结构中的元素产生引用

* 每个指针都对应一个类型.这个类型表明该指针指向的是哪一类对象
* 每个指针都有一个值.这个值是某个指定类型的对象的地址.特殊的NULL(0)值表示该指针没有指向任何地方
* 指针用‘&’运算符创建.这个运算符可以应用到任何lvalue类的C表达式上,lvalue意指可以出现在赋值语句左边的表达式.这样的例子包括变量以及结构、联合和数组的元素.因为leaq指令是设计用来计算内存引用的地址的, &运算符的机器代码实现常常用这条指令来计算表达式的值
* *操作符用于间接引用指针.其结果是一个值,它的类型与该指针的类型一致.间接引用是用内存引用来实现的,要么是存储到一个指定的地址,要么是从指定的地址读取
* 数组与指针紧密联系.一个数组的名字可以像一个指针变量一样引用(但是不能修改).数组引用与指针运算和间接引用有一样的效果.数组引用和指针运算都需要用对象大小对偏移量进行伸缩.当我们写表达式p+i,这里指针p的值为$p$,得到的地址计算为$p+L\cdot i$,这里L是与p相关联的数据类型的大小
* 将指针从一种类型强制转换成另一种类型,只改变它的类型,而不改变它的值.强制类型转换的一个效果是改变指针运算的伸缩
* 指针也可以指向函数.这提供了一个很强大的存储和向代码传递引用的功能,这些引用可以被程序的某个其他部分调用

### 使用GDB调试器

启动GDB:

```
linux> gab prog
```

通常的方法是在程序中感兴趣的地方附近设置断点.断点可以设置在函数入口后面,或是一个程序的地址处.程序在执行过程中遇到一个断点时,程序会停下来,并将控制返回给用户.在断点处,我们能够以各种方式查看各个寄存器和内存位置.我们也可以单步跟踪程序,一次只执行几条指令,或是前进到下一个断点

![image-20210704132031099](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210704132031099.png)

### 内存越界引用和缓冲区溢出

C对于数组引用不进行任何边界检查,而且局部变量和状态信息(例如保存的寄存器值和返回地址)都存放在栈中.这两种情况结合到一起就能导致严重的程序错误,对越界的数组元素的写操作会破坏存储在栈中的状态信息.当程序使用这个被破坏的状态,试图重新加载寄存器或执行ret指令时,就会出现很严重的错误

一种特别常见的状态破坏称为缓冲区溢出(buffer overflow),通常,在栈中分配某个字符数组来保存一个字符串,但是字符串的长度超出了为数组分配的空间

> 蠕虫和病毒
>
> 蠕虫和病毒都试图在计算机中传播它们自己的代码段.蠕虫(worm)可以自己运行,并且能够将自己的等效副本传播到其他机器.病毒(virus)能将自己添加到包括操作系统在内的其他程序中,但它不能独立运行.在一些大众媒体中, “病毒”用来指各种在系统间传播攻击代码的策略,所以你可能会听到人们把本来应该叫做“蠕虫”的东西称为“病毒”

### 对抗缓冲区溢出攻击

缓冲区溢出攻击的普遍发生给计算机系统造成了许多的麻烦.现代的编译器和操作系统实现了很多机制,以避免遭受这样的攻击,限制入侵者通过缓冲区溢出攻击获得系统控制的方式

#### 栈随机化

为了在系统中插入攻击代码,攻击者既要插入代码,也要插入指向这段代码的指针,这个指针也是攻击字符串的一部分.产生这个指针需要知道这个字符串放置的栈地址.在过去,程序的栈地址非常容易预测.对于所有运行同样程序和操作系统版本的系统来说,在不同的机器之间,栈的位置是相当固定的.因此,如果攻击者可以确定一个常见的Web服务器所使用的栈空间,就可以设计一个在许多机器上都能实施的攻击.以传染病来打个比方,许多系统都容易受到同一种病毒的攻击,这种现象常被称作安全单一化(securitymonoculture)

栈随机化的思想使得栈的位置在程序每次运行时都有变化.因此,即使许多机器都运行同样的代码,它们的栈地址都是不同的.实现的方式是:程序开始时,在栈上分配一段0~1字节之间的随机大小的空间,例如,使用分配函数alloca在栈上分配指定字节数量的空间.程序不使用这段空间,但是它会导致程序每次执行时后续的栈位置发生了变化.分配的范围n必须足够大,才能获得足够多的栈地址变化,但是又要足够小,不至于浪费程序太多的空间

然而,一个执著的攻击者总是能够用蛮力克服随机化,他可以反复地用不同的地址进行攻击.一种常见的把戏就是在实际的攻击代码前插入很长一段的nop(读作"no op", no operatioin的缩写)指令.执行这种指令除了对程序计数器加一,使之指向下一条指令之外,没有任何的效果.只要攻击者能够猜中这段序列中的某个地址,程序就会经过这个序列,到达攻击代码.这个序列常用的术语是“空操作雪橇(nop sled)",意思是程序会“滑过”这个序列

#### 栈破坏检测

计算机的第二道防线是能够检测到何时栈已经被破坏.破坏通常发生在当超越局部缓冲区的边界时.在C语言中,没有可靠的方法来防止对数组的越界写.但是,我们能够在发生了越界写的时候,在造成任何有害结果之前,尝试检测到它

最近的GCC版本在产生的代码中加人了一种栈保护者(stack protector)机制,来检测缓冲区越界.其思想是在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀(canary)值,这个金丝雀值,也称为哨兵值(guard value),是在程序每次运行时随机产生的,因此,攻击者没有简单的办法能够知道它是什么.在恢复寄存器状态和从函数返回之前,程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个函数的某个操作改变了.如果是的,那么程序异常中止

![image-20210704161919779](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210704161919779.png)

#### 限制可执行代码区域

最后一招是消除攻击者向系统中插入可执行代码的能力.一种方法是限制哪些内存区域能够存放可执行代码.在典型的程序中,只有保存编译器产生的代码的那部分内存才需要是可执行的.其他部分可以被限制为只允许读和写.虚拟内存空间在逻辑上被分成了页(page),典型的每页是2048或者4096个字节.硬件支持多种形式的内存保护,能够指明用户程序和操作系统内核所允许的访问形式.许多系统允许控制三种访问形式:读(从内存读数据)、写(存储数据到内存)和执行(将内存的内容看作机器级代码).以前, x86体系结构将读和执行访问控制合并成一个1位的标志,这样任何被标记为可读的页也都是可执行的.栈必须是既可读又可写的,因而栈上的字节也都是可执行的.已经实现的很多机制,能够限制一些页是可读但是不可执行的,然而这些机制通常会带来严重的性能损失

最近, AMD为它的64位处理器的内存保护引入了"NX" (No-Execute,不执行)位,将读和执行访问模式分开, Intel也跟进了.有了这个特性,栈可以被标记为可读和可写,但是不可执行,而检查页是否可执行由硬件来完成,效率上没有损失

有些类型的程序要求动态产生和执行代码的能力. “即时(just-in-time)”编译技术为解释语言(例如Java)编写的程序动态地产生代码,以提高执行性能.是否能够将可执行代码限制在由编译器在创建原始程序时产生的那个部分中,取决于语言和操作系统

随机化、栈保护和限制哪部分内存可以存储可执行代码是用于最小化程序缓冲区溢出攻击漏洞三种最常见的机制.它们都具有这样的属性,即不需要程序员做任何特殊的努力,带来的性能代价都非常小,甚至没有.单独每一种机制都降低了漏洞的等级,而组合起来,它们变得更加有效.不幸的是,仍然有方法能够攻击计算机,因而端虫和病毒继续危害着许多机器的完整性

### 支持变长栈帧

到目前为止,我们已经检查了各种函数的机器级代码,但它们有一个共同点,即编译器能够预先确定需要为栈帧分配多少空间.但是有些函数,需要的局部存储是变长的

为了管理变长栈帧, x86-64代码使用寄存器%rbp作为帧指针(frame pointer) (有时称为基指针(base pointer),这也是 %rbp中bp两个字母的由来),当使用帧指针时,栈帧的组织结构与函数vframe的情况一样.可以看到代码必须把%rbp之前的值保存到栈中,因为它是一个被调用者保存寄存器.然后在函数的整个执行过程中,都使得%rbp指向那个时刻栈的位置,然后用固定长度的局部变量相对于%rbp的偏移量来引用它们

![image-20210704165118875](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210704165118875.png)

在函数的开始,代码建立栈帧,并为数组分配空间.首先把%rbp的当前值压入栈中,将%rbp设置为指向当前的栈位置,然后,在栈上分配16个字节,其中前8个字节用于存储局部变量i,而后8个字节是未被使用的.接着,为数组分配空间

## 浮点代码

处理器的浮点体系结构包括多个方面,会影响对浮点数据操作的程序如何被映射到机器上,包括:

* 如何存储和访问浮点数值.通常是通过某种寄存器方式来完成
* 对浮点数据操作的指令
* 向函数传递浮点数参数和从函数返回浮点数结果的规则
* 函数调用过程中保存寄存器的规则

1997年出现了Pentium/MMX, Intel和AMD都引入了持续数代的媒体(media)指令,支持图形和图像处理.这些指令本意是允许多个操作以并行模式执行,称为单指令多数据或SIMD(读作sim-dee).在这种模式中,对多个不同的数据并行执行同一个操作.名字经过了一系列大的修改,从MMX到SSE (Streaming SIMD Extension,流式SIMD扩展),以及最新的AVX(Advanced Vector Extension,高级向量扩展).每一代中,都有一些不同的版本.每个扩展都是管理寄存器组中的数据,这些寄存器组在MMX中称为"MM"寄存器, SSE中称为"XMM"寄存器,而在AVX中称为"YMM"寄存器;MM寄存器是64位的, XMM是128位的,而YMM是256位的.所以,每个YMM寄存器可以存放8个32位值,或4个64位值,这些值可以是整数,也可以是浮点数

2000年Pentium 4中引入了SSE2,媒体指令开始包括那些对标量浮点数据进行操作的指令,使用XMM或YMM寄存器的低32位或64位中的单个值.这个标量模式提供了一组寄存器和指令,它们更类似于其他处理器支持浮点数的方式.所有能够执行x86-64代码的处理器都支持SSE2或更高的版本,因此x86-64浮点数是基于SSE或AVX的,包括传递过程参数和返回值的规则

AVX浮点体系结构允许数据存储在16个YMM寄存器中,它们的名字为%ymm0~%ymm15.每个YMM寄存器都是256位(32字节).当对标量数据操作时,这些寄存器只保存浮点数,而且只使用低32位(对于float)或64位(对于double),江编代码用寄存器的SSE XMM寄存器名字&xmmno~8xmm15来引用它们,每个XMM寄存器都是对应的YMM寄存器的低128位(16字节)

![image-20210705101323412](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705101323412.png)

### 浮点传送和转换操作

引用内存的指令是标量指令,意味着它们只对单个而不是一组封装好的数据值进行操作.数据要么保存在内存中(由表中的$M_{32}$和$M_{64}$,指明),要么保存在XMM寄存器中,无论数据对齐与否,这些指令都能正确执行,不过代码优化规则建议32位内存数据满足4字节对齐, 64位数据满足8字节对齐.内存引用的指定方式与整数MOV指令的一样,包括偏移量、基址寄存器、变址寄存器和伸缩因子的所有可能的组合

![image-20210705101902446](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705101902446.png)

GCC只用标量传送操作从内存传送数据到XMM寄存器或从XMM寄存器传送数据到内存.对于在两个XMM寄存器之间传送数据, GCC会使用两种指令之一,即用vmovaps传送单精度数,用vmovapd传送双精度数.对于这些情况,程序复制整个寄存器还是只复制低位值既不会影响程序功能,也不会影响执行速度,所以使用这些指令还是针对标量数据的指令没有实质上的差别.指令名字中的字母‘a’,表示"aligned(对齐的)"当用于读写内存时,如果地址不满足16字节对齐,它们会导致异常.在两个寄存器之间传送数据,绝不会出现错误对齐的状况

![image-20210705104223138](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705104223138.png)

```cpp
// Conversion from single to double precision
vunpcklps %xmm0,%xmm0,%xmm0		Replicate first vector element
vcvtps2pd %xmm0,%xmm0			Convert two elements to double
```

vunpcklps指令通常用来交叉放置来自两个XMM寄存器的值,把它们存储到第三个寄存器中.也就是说,如果一个源寄存器的内容为字$[s_3 , s_2, s_1, s_0]$,另一个源寄存器为字$[d_3, d_2, d_1, d_0]$,那么目的寄存器的值会是$[s_1 , d_1, s_0, d_0]$.三个操作数使用同一个寄存器,所以如果原始寄存器的值为$[x_1, x_2, x_3, x_4]$,那么该指令会将寄存器的值更新为值$[x_1, x_1, x_0, x_0]$

vcvtps2pd指令把源XMM寄存器中的两个低位单精度值扩展成目的XMM寄存器中的两个双精度值.对前面vunpcklps指令的结果应用这条指令会得到值$[dx0, dxo]$,这里$dxo$是将x转换成双精度后的结果

```cpp
// Conversion from double to single percision
vmovddup %xmm0,%xmm0		Replicate first vector element
vevtpd2psx %xmm0,%xmm0		Convert two vector elements to single
```

### 过程中的浮点代码

在x86-64中, XMM寄存器用来向函数传递浮点参数,以及从函数返回浮点值

* XMM寄存器%xmmo~%xmm7最多可以传递8个浮点参数.按照参数列出的顺序使用这些寄存器.可以通过栈传递额外的浮点参数
* 函数使用寄存器%xmm0来返回浮点值
* 所有的XMM寄存器都是调用者保存的.被调用者可以不用保存就覆盖这些寄存器中任意一个

### 浮点运算操作

![image-20210705114702314](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705114702314.png)

### 定义和使用浮点常数

和整数运算操作不同, AVX浮点操作不能以立即数值作为操作数.相反,编译器必须为所有的常量值分配和初始化存储空间.然后代码在把这些值从内存读入

### 在浮点代码中使用位级操作

![image-20210705131440234](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705131440234.png)

有时GCC生成的代码会在XMM寄存器上执行位级操作,得到有用的浮点结果

### 浮点比较操作

![image-20210705131758465](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705131758465.png)

这些指令类似于CMP指令,它们都比较操作数$S_1$和$S_2$(但是顺序可能与预计的相反),并且设置条件码指示它们的相对值.与cmpq一样,它们遵循以相反顺序列出操作数的ATT格式惯例.参数$S_2$必须在XMM寄存器中,而$S_1$可以在XMM寄存器中,也可以在内存中

浮点比较指令会设置三个条件码:零标志位ZF、进位标志位CF和奇偶标志位PF.奇偶标志位对于整数操作,当最近的一次算术或逻辑运算产生的值的最低位字节是偶校验的(即这个字节中有偶数个1),那么就会设置这个标志位.不过对于浮点比较,当两个操作数中任一个是$NaN$时,会设置该位.根据惯例, C语言中如果有个参数为$NaN$,就认为比较失败了,这个标志位就被用来发现这样的条件

条件码的设置条件如下:

![image-20210705132258605](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705132258605.png)

当任一操作数为NaN时,就会出现无序的情况.可以通过奇偶标志位发现这种情况.通常jp(jump on parity)指令是条件跳转,条件就是浮点比较得到一个无序的结果.除了这种情况以外,进位和零标志位的值都和对应的无符号比较一样:当两个操作数相等时,设置ZF;当$S_2$<$S_1$时,设置CF,像ja和jb这样的指令可以根据标志位的各种组合进行条件跳转

# 处理器体系结构

到目前为止,我们看到的计算机系统只限于机器语言程序级.我们知道处理器必须执行一系列指令,每条指令执行某个简单操作.指令被编码为由一个或多个字节序列组成的二进制格式.一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构(Instruction-Set Architecture, ISA),不同的处理器“家族”,例如Intel IA32和x86-64,IBM/Freescale Power和ARM处理器家族,都有不同的ISA,==一个程序编译成在一种机器上运行,就不能在另一种机器上运行==

另外,同一个家族里也有很多不同型号的处理器.虽然每个厂商制造的处理器性能和复杂性不断提高,但是不同的型号在ISA级别上都保持着兼容.一些常见的处理器家族(例如x86-64)中的处理器分别由多个厂商提供.因此, ISA在编译器编写者和处理器设计人员之间提供了一个概念抽象层,编译器编写者只需要知道允许哪些指令,以及它们是如何编码的;而处理器设计者必须建造出执行这些指令的处理器

创建一个流水线化的处理器(pipelined processor).这个处理器将每条指令的执行分解成五步,每个步骤由一个独立的硬件部分或阶段(stage)来处理.指令步经流水线的各个阶段,且每个时钟周期有一条新指令进人流水线.所以,处理器可以同时执行五条指令的不同阶段.为了使这个处理器保留Y86-64 ISA的顺序行为,就要求处理很多冒险或冲突(hazard)情况,==冒险就是一条指令的位置或操作数依赖于其他仍在流水线中的指令==

## Y86-64指令集体系结构

定义一个指令集体系结构(例如Y86-64)包括定义各种状态单元、指令集和它们的编码、一组编程规范和异常事件处理

### 程序员可见的状态

Y86-64程序中的每条指令都会读取或修改处理器状态的某些部分.这称为程序员可见状态,这里的“程序员”既可以是用汇编代码写程序的人,也可以是产生机器级代码的编译器.在处理器实现中,只要我们保证机器级程序能够访问程序员可见状态,就不需要完全按照ISA暗示的方式来表示和组织这个处理器状态.Y86-64的状态类似于x86-64,==有15个程序寄存器:%rax、%rcx、%rdx、%rbx、%rsp、%rbp、%rsi、%rdi和 %r8到%r14==

每个程序寄存器存储一个64位的字.==寄存器%rsp被入栈、出栈、调用和返回指令作为栈指针==.除此之外,寄存器没有固定的含义或固定值.有3个一位的条件码:==ZF、SF和OF==,它们保存着最近的算术或逻辑指令所造成影响的有关信息.==程序计数器(PC)存放当前正在执行指令的地址==

内存从概念上来说就是一个很大的字节数组,保存着程序和数据.Y86-64程序用虚拟地址来引用内存位置.硬件和操作系统软件联合起来将虚拟地址翻译成实际或物理地址,指明数据实际存在内存中哪个地方

### Y86-64指令

这个指令集就是我们处理器实现的目标.Y86-64指令集基本上是x86-64指令集的一个子集.它只包括8字节整数操作,寻址方式较少,操作也较少.因为我们只有8字节数据,所以称之为“字(word)"不会有任何歧义

* x86-64的movq指令分成了4个不同的指令: irmovq, rrmovq, mrmovq和rmmovq,分别显式地指明源和目的的格式.源可以是立即数(i)、寄存器(r)或内存(m).指令名字的第一个字母就表明了源的类型.目的可以是寄存器(r)或内存(m),指令名字的第二个字母指明了目的的类型.在决定如何实现数据传送时,显式地指明数据传送的1这4种类型是很有帮助的
* 有4个整数操作指令.它们是addg, subq, anda和xorg.它们只对寄存器数据进行操作,而x86-64还允许对内存数据进行这些操作.这些指令会设置3个条件码ZF, SE和OF(零、符号和溢出)
* 7个跳转指令是jmp,jle, jl, je, jne, jge和jg.根据分支指令的类型和条件代码的设置来选择分支.分支条件和x86-64的一样
* 有6个条件传送指令: cmovle,cmovl, cmove,cmovne,cmovge 和 cmovg.这些指令的格式与寄存器-寄存器传送指令rrmovq一样,但是只有当条件码满足所需要的约束时,才会更新目的寄存器的值
* call指令将返回地址入栈,然后跳到目的地址.ret令从这样的调用中返回
* pushq和popq指令实现了入栈和出栈,就像在x86-64中一样
* halt指令停止指令的执行.x86-64中有一个与之相当的指令hlt, x86-64的应用程序不允许使用这条指令,因为它会导致整个系统暂停运行.对于Y86-64来说,执行halt指令会导致处理器停止,并将状态码设置为HLT

### 指令编码

每条指令需要1 ~ 10个字节不等,这取决于需要哪些字段.每条指令的第一个字节表明指令的类型.这个字节分为两个部分,每部分4位:高4位是代码(code)部分,低4位是功能(function)部分.功能值只有在一组相关指令共用一个代码时才有用

![image-20210705153536484](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705153536484.png)

15个程序寄存器中每个都有一个相对应的范围在0到0xE之间的寄存器标识符(register ID), Y86-64中的寄存器编号跟x86-64中的相同.程序寄存器存在CPU中的一个寄存器文件中,这个寄存器文件就是一个小的、以寄存器ID作为地址的随机访问存储器.在指令编码中以及在我们的硬件设计中,当需要指明不应访问任何寄存器时,就用ID值OxF来表示

![image-20210705153624277](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705153624277.png)

有的指令只有一个字节长,而有的需要操作数的指令编码就更长一些.首先,可能有附加的寄存器指示符字节(register specifier byte),指定一个或两个寄存器.从指令的汇编代码表示中可以看到,根据指令类型,指令可以指定用于数据源和目的的寄存器,或是用于地址计算的基址寄存器.没有寄存器操作数的指令,就没有寄存器指示符字节.那些只需要一个寄存·器操作数的指令(irmovq, pushq和popq)将另一个寄存器指示符设为OxF,这种约定在我们的处理器实现中非常有用

有些指令需要一个附加的4字节常数字(constant word).这个字能作为irmovq的立即数数据, rmmovq和mrmovq的地址指示符的偏移量,以及分支指令和调用指令的目的地址.处理器使用PC相对寻址方式,分支指令的编码会更简洁,同时这样也能允许代码从内存的一部分复制到另一部分而不需要更新所有的分支目标地址

指令集的一个重要性质就是字节编码必须有唯一的解释.任意一个字节序列要么是一个唯一的指令序列的编码,要么就不是一个合法的字节序列.Y86-64就具有这个性质,因为每条指令的第一个字节有唯一的代码和功能组合,给定这个字节,我们就可以决定所有其他附加字节的长度和含义.这个性质保证了处理器可以无二义性地执行目标代码程序.即使代码嵌入在程序的其他字节中,只要从序列的第一个字节开始处理,我们仍然可以很容易地确定指令序列.反过来说,如果不知道一段代码序列的起始位置,我们就不能准确地确定怎样将序列划分成单独的指令.对于试图直接从目标代码字节序列中抽取出机器级程序的反汇编程序和其他一些工具来说,这就带来了问题

> RISC和CISC指令集
>
> ![image-20210705170253168](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705170253168.png)

### Y86-64异常

![image-20210705170840829](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705170840829.png)

对Y86-64来说,程序员可见的状态包括状态码stat,它描述程序执行的总体状态.代码值1,命名为AOK,表示程序执行正常,而其他一些代码则表示发生了某种类型的异常.代码2,命名为HLT,表示处理器执行了一条halt指令.代码3,命名为ADR,表示处理器试图从一个非法内存地址读或者向一个非法内存地址写,可能是当取指令的时候,也可能是当读或者写数据的时候.代码4,命名为INS,表示遇到了非法的指令代码

对于Y86-64,当遇到这些异常的时候,我们就简单地让处理器停止执行指令.在更完整的设计中,处理器通常会调用一个异常处理程序(exception handler),这个过程被指定用来处理遇到的某种类型的异常.异常处理程序可以被配置成不同的结果,例如,中止程序或者调用一个用户自定义的信号处理程序(signal handler)

x86-64代码是由GCC编译器产生的.Y86-64代码与之类似,但有以下不同点

* Y86-64将常数加载到寄存器,因为它在算术指令中不能使用立即数
* 要实现从内存读取一个数值并将其与一个寄存器相加, Y86-64代码需要两条指令,而x86-64只需要一条addq指令

以“.”开头的词是汇编器伪指令(assembler directives),它们告诉汇编器调整地址,以便在那儿产生代码或插入一些数据

### 一些Y86-64指令的详情

大多数Y86-64指令是以一种直接明了的方式修改程序状态的,所以定义每条指令想要达到的结果并不困难.不过,两个特别的指令的组合需要特别注意一下

pushq指令会把栈指针减8,并且将一个寄存器值写入内存中.因此,当执行pushq &rsp指令时,处理器的行为是不确定的,因为要入栈的寄存器会被同一条指令修改.通常有两种不同的约定: 

1.  压入sp的原始值
2. 压入减去8的rsp的值

## 逻辑设计和硬件控制语言HCL

在硬件设计中,用电子电路来计算对位进行运算的函数,以及在各种存储器单元中存储位.大多数现代电路技术都是用信号线上的高电压或低电压来表示不同的位值.在当前的技术中,逻辑1是用1.0伏特左右的高电压表示的,而逻辑0是用0.0伏特左右的低电压表示的.==要实现一个数字系统需要三个主要的组成部分:计算对位进行操作的函数的组合逻辑、存储位的存储器单元,以及控制存储器单元更新的时钟信号==

> 现代逻辑设计
>
> 曾经,硬件设计者通过描绘示意性的逻辑电路图来进行电路设计(最早是用纸和笔,后来是用计算机图形终端).现在,大多数设计都是用硬件描述语言(Hardware Description Language, HDL)来表达的.HDL是一种文本表示,看上去和编程语言类似,但是它是用来描述硬件结构而不是程序行为的.==最常用的语言是Verilog,它的语法类似于C;另一种是VHDL,它的语法类似于编程语言Ada==,这些语言本来都是用来表示数字电路的模拟模型的.20世纪80年代中期,研究者开发出了逻辑合成(logic synthesis)程序,:它可以根据HDL的描述生成有效的电路设计.现在有许多商用的合成程序,已经成为产生数字电路的主要技术.从手工设计电路到合成生成的转变就好像从写汇编程序到写高级语言程序,再用编译器来产生机器代码的转变一样
>
> 我们的HCL语言只表达硬件设计的控制部分,只有有限的操作集合,也没有模块化.不过,正如我们会看到的那样,控制逻辑是设计微处理器中最难的部分.我们已经开发出了将HCL直接翻译成Verilog的工具,将这个代码与基本硬件单元的Verilog代码结合起来,就能产生HDL描述,根据这个HDL描述就可以合成实际能够工作的微处理器.通过小心地分离、设计和测试控制逻辑,再加上适当的努力,我们就能创建出一个可以工作的微处理器

### 逻辑门

![image-20210705180843910](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210705180843910.png)

逻辑门是数字电路的基本计算单元.它们产生的输出,等于它们输入位值的某个布尔函数.图是布尔函数AND,OR和NOT的标准符号, C语言中运算符的逻辑门下面是对应的HCL表达式: AND用&&表示, OR用||表示,而NOT用!表示.我们用这些符号而不用C语言中的位运算符&、|和~,这是因为逻辑门只对单个位的数进行操作,而不是整个字

逻辑门总是活动的(active),一旦一个门的输入变化了,在很短的时间内,输出就会相应地变化

### 组合电路和HCL布尔表达式

将很多的逻辑门组合成一个网,就能构建计算块(computational block),称为组合电路(combinational circuits),如何构建这些网有几个限制

* 每个逻辑门的输入必须连接到下述选项之一: 1)一个系统输入(称为主输人), 2)某个存储器单元的输出, 3)某个逻辑门的输出
* 两个或多个逻辑门的输出不能连接在一起.否则它们可能会使线上的信号矛盾,可能会导致一个不合法的电压或电路故障
* 这个网必须是无环的.也就是在网中不能有路径经过一系列的门而形成一个回路,这样的回路会导致该网络计算的函数有歧义

==多路复用器(multiplexor,通常称为"MUX")==.多路复用器根据输入控制信号的值,从一组不同的数据信号中选出一个.在这个单个位的多路复用器中,两个数据信号是输入位a和b,控制信号是输入位s.当s为1时,输出等于a;而当s为0时,输出等于b,在这个电路中,我们可以看出两个AND门决定了是否将它们相对应的数据输入传送到OR门.当s为0时,上面的AND门将传送信号b(因为这个门的另一个输入是!s),而当s为1时,下面的AND门将传送信号a

HCL表达式很清楚地表明了组合逻辑电路和C语言中逻辑表达式的对应之处.它们都是用布尔操作来对输入进行计算的函数.值得注意的是,这两种表达计算的方法之间有以下区别:

* 因为组合电路是由一系列的逻辑门组成,它的属性是输出会持续地响应输人的变化.如果电路的输入变化了,在一定的延迟之后,输出也会相应地变化.相比之下, C表达式只会在程序执行过程中被遇到时才进行求值
* C的逻辑表达式允许参数是任意整数, ==0表示FALSE,其他任何值都表示TRUE==.而逻辑门只对位值0和1进行操作
* c的逻辑表达式有个属性就是它们可能只被部分求值.如果一个AND或OR操作的结果只用对第一个参数求值就能确定,那么就不会对第二个参数求值了

### 字级的组合电路和HCL整数表达式

通过将逻辑门组合成大的网,可以构造出能计算更加复杂函数的组合电路.通常,我们设计能对数据字(word)进行操作的电路.有一些位级信号,代表一个整数或一些控制模式

执行字级计算的组合电路根据输入字的各个位,用逻辑门来计算输出字的各个位

在HCL中,我们将所有字级的信号都声明为int,不指定字的大小.这样做是为了简单.在全功能的硬件描述语言中,每个字都可以声明为有特定的位数

![image-20210706112652367](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706112652367.png)

允许不互斥的选择表达式使得HCL代码的可读性更好.实际的硬件多路复用器的信号必须互斥,它们要控制哪个输入字应该被传送到输出.要将个HCL情况表达式翻译成硬件,逻辑合成程序需要分析选择表达式集合,并解决任何可能的冲突,确保只有第一个满足的情况才会被选中

![image-20210706113002450](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706113002450.png)

组合逻辑电路可以设计成在字级数据上执行许多不同类型的操作.==算术/逻辑单元(ALU)==是一种很重要的组合电路.这个电路有三个输入:标号为A和B的两个数据输入,以及一个控制输人.根据控制输入的设置,电路会对数据输入执行不同的算术或逻辑操作.这个ALU中画的四个操作对应于Y86-64指令集支持的四种不同的整数操作,而控制值和这些操作的功能码相对应,减法的操作数顺序,是输入B减去输入A之所以这样做,是为了使这个顺序与subq指令的参数顺序一致

### 集合关系

![image-20210706115120791](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706115120791.png)

在处理器设计中,很多时候都需要将一个信号与许多可能匹配的信号做比较,以此来检测正在处理的某个指令代码是否属于某一类指令代码

### 存储器和时钟

组合电路从本质上讲,不存储任何信息.相反,它们只是简单地响应输入信号,产生等于输入的某个函数的输出.为了产生==时序电路==(sequential circuit),也就是有状态并且在这个状态上进行计算的系统,我们必须引入按位存储信息的设备.存储设备都是由同一个时钟控制的,时钟是一个周期性信号,决定什么时候要把新值加载到设备中

* 时钟寄存器(简称寄存器)存储单个位或字.时钟信号控制寄存器加载输入值
* 随机访问存储器(简称内存)存储多个字,用地址来选择该读或该写哪个字.随机访问存储器的例子包括: 1)处理器的虚拟内存系统,硬件和操作系统软件结合起来使处理器可以在一个很大的地址空间内访问任意的字; 2)寄存器文件,在此,寄存器标识符作为地址.在IA32或Y86-64处理器中,寄存器文件有15个程序寄存器(%rax~%r14)

硬件和机器级编程, “寄存器”这个词是两个有细微差别的事情.在硬件中,寄存器直接将它的输入和输出线连接到电路的其他部分.==在机器级编程中,寄存器代表的是CPU中为数不多的可寻址的字,这里的地址是寄存器ID==.这些字通常都存在寄存器文件中,虽然我们会看到硬件有时可以直接将一个字从一个指令传送到另一个指令,以避免先写寄存器文件再读出来的延迟.需要避免歧义时,我们会分别称呼这两类寄存器为“硬件寄存器”和“程序寄存器”

大多数时候,寄存器都保持在稳定状态(用x表示),产生的输出等于它的当前状态.信号沿着寄存器前面的组合逻辑传播,这时,产生了一个新的寄存器输入(用y表示),但只要时钟是低电位的,寄存器的输出就仍然保持不变.当时钟变成高电位的时候,输入信号就加载到寄存器中,成为下一个状态y,直到下一个时钟上升沿,这个状态就一直是寄存器的新输出.关键是寄存器是作为电路不同部分中的组合逻辑之间的屏障.每当每个时钟到达上升沿时,值才会从寄存器的输入传送到输出.我们的Y86-64处理器会用时钟寄存器保存程序计数器(PC)、条件代码(CC)和程序状态(Stat)

![image-20210706182003459](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706182003459.png)

向寄存器文件写入字是由时钟信号控制的,控制方式类似于将值加载到时钟寄存器.每次时钟上升时,输入的值会被写入寄存器ID指示的程序寄存器

> 现实的存储器设计
>
> 真实微处理器中的存储器系统是由几种形式的硬件存储器组成的,包括几种随机访问存储器和磁盘,以及管理这些设备的各种硬件和软件机制

## Y86-64的顺序实现

SEQ("sequential"顺序的)处理器.每个时钟周期上, SEQ执行处理一条完整指令所需的所有步骤.不过,这需要一个很长的时钟周期时间,因此时钟周期频率会低到不可接受

### 将处理组织成阶段

通常,处理一条指令包括很多操作.将它们组织成某个特殊的阶段序列,即使指令的动作差异很大,但所有的指令都遵循统一的序列.每一步的具体处理取决于正在执行的指令.创建这样一个框架,我们就能够设计一个充分利用硬件的处理器.下面是关于各个阶段以及各阶段内执行操作的简略描述:

```mermaid
graph LR
取指F-->译码D-->执行E-->访存M-->写回W-->更新
```



* ==取指(fetch)==:取指阶段从内存读取指令字节,地址为程序计数器(PC)的值.从指令中抽取出指令指示符字节的两个四位部分,称为icode(指令代码)和ifun(指令功能).它可能取出一个寄存器指示符字节,指明一个或两个寄存器操作数指示符rA和rB.它还可能取出一个四字节常数字valC,它按顺序方式计算当前指令的下一条指令的地址valP.也就是说, valP等于PC的值加上已取出指令的长度
* ==译码(decode)==:译码阶段从寄存器文件读入最多两个操作数,得到值va1A和/或valB.通常,它读入指令rA和rB字段指明的寄存器,不过有些指令是读寄存器%rsp的
* ==执行(execute)==:在执行阶段,算术/逻辑单元(ALU)要么执行指令指明的操作(根据ifun的值),计算内存引用的有效地址,要么增加或减少栈指针.得到的值我们称为valE.在此,也可能设置条件码.对一条条件传送指令来说,这个阶段会检验条件码和传送条件(由ifun给出),如果条件成立,则更新目标寄存器.同样,对一条跳转指令来说,这个阶段会决定是不是应该选择分支
* ==访存(memory)==:访存阶段可以将数据写入内存,或者从内存读出数据.读出的值valM
* ==写回(write back)==:写回阶段最多可以写两个结果到寄存器文件
* ==更新PC(PC update)==:将PC设置成下一条指令的地址

处理器无限循环,执行这些阶段.在我们简化的实现中,发生任何异常时,处理器就会停止:它执行halt指令或非法指令,或它试图读或者写非法地址.在更完整的设计中,处理器会进入异常处理模式,开始执行由异常的类型决定的特殊代码.

执行一条指令是需要进行很多处理.不仅必须执行指令所表明的操作,还必须计算地址、更新栈指针,以及确定下一条指令的地址.幸好每条指令的整个流程都比较相似.因为我们想使硬件数量尽可能少,并且最终将把它映射到一个二维的集成电路芯片的表面,在设计硬件时,一个非常简单而一致的结构是非常重要的.降低复杂度的一种方法是让不同的指令共享尽量多的硬件.每个处理器设计都只含有一个算术/逻辑单元,根据所执行的指令类型的不同,它的使用方式也不同.在硬件上复制逻辑块的成本比软件中有重复代码的成本大得多.而且在硬件系统中处理许多特殊情况和特性要比用软件来处理困难得多

![image-20210706195958545](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706195958545.png)

![image-20210706200015491](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706200015491.png)

![image-20210706200023952](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706200023952.png)

![image-20210706200121783](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706200121783.png)

![image-20210706200130709](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706200130709.png)

### SEQ硬件结构

![image-20210706200216505](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706200216505.png)

实现所有Y86-64指令所需要的计算可以被组织成6个基本阶段:取指、译码、执行、访存、写回和更新PC.程序计数器放在寄存器中,在图中左下角(标明为"PC").然后,信息沿着线流动(多条线组合在一起就用宽一点的灰线来表示),先向上,再向右.同各个阶段相关的硬件单元(hardwareunits)负责执行这些处理.在右边,反馈线路向下,包括要写到寄存器文件的更新值,以及更新的程序计数器值.在SEQ中,所有硬件单元的处理都在一个时钟周期内完成

* ==取指==:将程序计数器寄存器作为地址,指令内存读取指令的字节.PC增加器(PC incre-tmenter)计算valp,即增加了的程序计数器
* ==译码==:寄存器文件有两个读端口A和B,从这两个端口同时读寄存器值valA和valB
* ==执行==:执行阶段会根据指令的类型,将算术/逻辑单元(ALU)用于不同的目的.对整数操作,它要执行指令所指定的运算.对其他指令,它会作为一个加法器来计算增加或减少栈指针,或者计算有效地址,或者只是简单地加0,将一个输入传递到输出
  条件码寄存器(CC)有三个条件码位.ALU负责计算条件码的新值.当执行条件传送指令时,根据条件码和传送条件来计算决定是否更新目标寄存器.同样,当执行一条跳转指令时,会根据条件码和跳转类型来计算分支信号Cnd
* ==访存==:在执行访存操作时,数据内存读出或写入一个内存字.指令和数据内存访问的是相同的内存位置,但是用于不同的目的
* ==写回==:寄存器文件有两个写端口.端口E用来写ALU计算出来的值,而端口M用来写从数据内存中读出的值
* ==PC更新==:程序计数器的新值选择自: valP,下一条指令的地址; valc,调用指令或跳转指指定的目标地址:valM,从内存读取的返回地址

![image-20210706201209488](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210706201209488.png)

![image-20210707111843474](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210707111843474.png)

### SEQ的时序

SEQ的实现包括组合逻辑和两种存储器设备:时钟寄存器(程序计数器和条件码寄存器),随机访问存储器(寄存器文件、指令内存和数据内存),组合逻辑不需要任何时序或控制-只要输人变化了,值就通过逻辑门网络传播

现在还剩四个硬件单元需要对它们的时序进行明确的控制-程序计数器、条件码寄存器、数据内存和寄存器文件.这些单元通过一个时钟信号来控制,它触发将新值装载到寄存器以及将值写到随机访问存储器.每个时钟周期,程序计数器都会装载新的指令地址.只有在执行整数运算指令时,才会装载条件码寄存器.只有在执行rmmovq, pushq或call指令时,才会写数据内存.寄存器文件的两个写端口允许每个时钟周期更新两个程序寄存器,不过可以用特殊的寄存器ID 0xF作为端口地址,来表明在此端口不应该执行写操作.要控制处理器中活动的时序,只需要寄存器和内存的时钟控制

原则:从不回读

处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态

### SEQ阶段的实现

![image-20210707155050963](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210707155050963.png)

#### 取指阶段

![image-20210707155132964](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210707155132964.png)

取指阶段包括指令内存硬件单元.以PC作为第一个字节(字节0)的地址,这个单元一次从内存读出10个字节.第一个字节被解释成指令字节, (标号为"Split"的单元)分为两个4位的数.然后,标号为"icode"和"ifun'的控制逻辑块计算指令和功能码,或者使之等于从内存读出的值,或者当指令地址不合法时(由信号imem_error指明),使这些值对应于nop指令

(当指令地址越界时会产生的)信号instr_valid和imem_error在访存阶段被用来产生状态码

#### 译码和写回阶段

![image-20210707155941501](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210707155941501.png)

寄存器文件有四个端口.它支持同时进行两个读(在端口A和B上)和两个写(在端口E和M上).每个端口都有一个地址连接和一个数据连接,地址连接是一个寄存器ID,而数据连接是一组64根线路,既可以作为寄存器文件的输出字(对读端口来说),也可以作为它的输入字(对写端口来说).两个读端口的地址输入为srcA和srcB,而两个写端口的地址输入为dstE和dstM,如果某个地址端口上的值为特殊标识符OxF(RNONE),则表明不需要访问寄存器

### 执行阶段

![image-20210707182005300](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210707182005300.png)

执行阶段包括算术/逻辑单元(ALU).这个单元根据alufun信号的设置,对输入aluA和aluB执行ADD/SUBTRACT/AND或EXCLUSIVEOR运算

#### 访存阶段

![image-20210707182147900](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210707182147900.png)

访存阶段的任务就是读或者写程序数据

#### 更新PC阶段

![image-20210707182309615](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210707182309615.png)

SEQ中最后一个阶段会产生程序计数器的新值,依据指令的类型和是否要选择分支,新的PC可能是valC, valM或valP

## 流水线的通用原理

### 计算流水线

![image-20210707182943901](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210707182943901.png)

![image-20210707183129517](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210707183129517.png)

在现代逻辑设计中,电路延迟以微微秒或皮秒(picosecond,简写成"ps"),也就是$10^{-12}$秒为单位来计算.流水线图(pipeline diagram),在图中,时间从左向右流动.从上到下写着一组操作.实心的长方形表示这些指令执行的时间.这个实现中,在开始下一条指令之前必须完成前一个.因此,这些方框在垂直方向上并没有相互重叠

### 流水线操作的详细说明

减缓时钟不会影响流水线的行为.信号传播到流水线寄存器的输入,但是直到时钟上升时才会改变寄存器的状态.

另一方面,如果时钟运行得太快,就会有灾难性的后果.值可能会来不及通过组合逻辑,因此当时钟上升时,寄存器的输人还不是合法的值.根据对SEQ处理器时序的讨论,这种在组合逻辑块之间采用时钟寄存器的简单机制,足够控制流水线中的指令流.随着时钟周而复始地上升和下降,不同的指令就会通过流水线的各个阶段,不会相互干扰

### 流水线的局限性

理想的流水线化的系统,在这个系统中,我们可以将计算分成三个相互独立的阶段,每个阶段需要的时间是原来逻辑需要时间的三分之一.不幸的是,会出现其他一些因素,降低流水线的效率

#### 不一致的划分

运行时钟的速率是由最慢的阶段的延迟限制的

![image-20210708105214641](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708105214641-1625712735740.png)

对硬件设计者来说,将系统计算设计划分成一组具有相同延迟的阶段是一个严峻的挑战.通常,处理器中的某些硬件单元,如ALU和内存,是不能被划分成多个延迟较小的单元的.这就使得创建一组平衡的阶段非常困难

#### 流水线过深,收益反而下降

![image-20210708105405214](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708105405214.png)

为了提高时钟频率,现代处理器采用了很深的(15或更多的阶段)流水线.处理器架构师将指令的执行划分成很多非常简单的步骤,这样一来每个阶段的延迟就很小.电路设计者小心地设计流水线寄存器,使其延迟尽可能得小.芯片设计者也必须小心地设计时钟传播网络,以保证时钟在整个芯片上同时改变

### 带反馈的流水线系统

![image-20210708105806835](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708105806835.png)

## Y86-64的流水线实现

### SEQ+:重新安排计算阶段

作为实现流水线化设计的一个过渡步骤,我们必须稍微调整一下SEQ中五个阶段的顺序,使得更新PC阶段在一个时钟周期开始时执行,而不是结束时才执行.只需要对整体硬件结构做最小的改动,对于流水线阶段中的活动的时序,它能工作得更好.我们称这种修改过的设计为“==SEQ+==”

![image-20210708111305128](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708111305128.png)

移动PC阶段,使得它的逻辑在时钟周期开始时活动,使它计算当前指令的PC值.在SEQ中, PC计算发生在时钟周期结束的时候,根据当前时钟周期内计算出的信号值来计算PC寄存器的·新值.在SEQ+中 ,创建状态寄存器来保存在一条指令执行过程中计算出来的信号.然后,当一个新的时钟周期开始时,这些信号值通过同样的逻辑来计算当前指令的PC,我们将这些寄存器标号为"plcode"、 "pCnd"等等,来指明在任一给定的周期,它们保存的是前一个周期中产生的控制信号

SEQ到SEQ+中对状态单元的改变是一种很通用的改进的例子,这种改进称为==电路重定时(circuit retiming)==.重定时改变了一个系统的状态表示,但是并不改变它的逻辑行为.通常用它来平衡一个流水线系统中各个阶段之间的延迟

> SEQ +中的PC
>
> SEQ+有一个很奇怪的特色,那就是没有硬件寄存器来存放程序计数器.而是根据从前一条指令保存下来的一些状态信息动态地计算PC,这就是一个小小的证明一我们可以以一种与ISA隐含着的概念模型不同的方式来实现处理器,只要处理器能正确执行任意的机器语言程序.我们不需要将状态编码成程序员可见的状态指定,的形式,只要处理器能够为任意的程序员可见状态(例如程序计数器)产生正确的值

### 插入流水线寄存器

在创建一个流水线化的Y86-64处理器的最初尝试中,我们要在SEQ+的各个阶段之间插入流水线寄存器,并对信号重新排列,得到PIPE-处理器,这里的“一”代表这个处理器和最终的处理器设计相比,性能要差一点.PIPE-的抽象结构如图所示

![image-20210708114830415](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708114830415.png)

流水线寄存器在该图中用黑色方框表示,每个寄存器包括不同的字段,用白色方框表示.正如多个字段表明的那样,每个流水线寄存器可以存放多个字节和字,同两个顺序处理器的硬件结构中的圆角方框不同,这些白色的方框表示实际的硬件组成

可以看到, PIPE-使用了与顺序设计SEQ几乎一样的硬件单元,但是有流水线寄存器分隔开这些阶段.流水线寄存器按如下方式标号:

| 标号 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| F    | 保存程序计数器的预测值                                       |
| D    | 位于取指和译码阶段之间.它保存关于最新取出的指令的信息,即将由译码阶段进行处理 |
| E    | 位于译码和执行阶段之间.它保存关于最新译码的指令和从寄存器文件读出的值的信息,即将由执行阶段进行处理 |
| M    | 位于执行和访存阶段之间.它保存最新执行的指令的结果,即将由访存阶段进行处理.它还保存关于用于处理条件车分支条件和分支目标的信息 |
| W    | 位于访存阶段和反馈路径之间,反馈踏径将计算出来的值提供给寄存器文件写,而当完成ret指令时,它还在联识别并翻,供返回地址 |

![image-20210708120054535](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708120054535.png)

### 对信号进行重新排列和标号

顺序实现SEQ和SEQ+在一个时刻只处理一条指令,因此诸如valC, srcA和valE这样的信号值有唯一的值

在流水线化的设计中,与各个指令相关联的这些值有多个版本,会随着指令一起流过系统.我们需要很小心以确保使用的是正确版本的信号,否则会有很严重的错误

通过在信号名前面加上大写的流水线寄存器名字作为前缀,存储在流水线寄存器中的信号可以唯一地被标识.例如, 4个状态码可,以被命名为D_stat, E_stat,M_stat和w_stat

还需要引用某些在一个阶段内刚刚计算出来的信号.它们的命名是在信号名前面加上小写的阶段名的第一个字母作为前缀.因而,这些块的输出被命名为f_stat和m_stat,我们还可以看到整个处理器的实际状态stat是根据流水线寄存器W中的状态值,由写回阶段中的块计算出来的

> 信号M-stat和m-stat的差别
>
> 在命名系统中,大写的前缀"D"、 "E"、"M"和"W"指的是流水线寄存器,所以M_stat指的是流水线寄存器M的状态码字段.小写的前缀"f"、"d"、 "e"、"m"和“w”指的是流水线阶段,所以m_stat指的是在访存阶段中由控制逻辑块产生出的状态信号

SEQ+和PIPE-的译码阶段都产生信号dstE和dstM,它们指明值valE和valM的目的寄存器.在SEQ+中,我们可以将这些信号直接连到寄存器文件写端口的地址输人.在PIPE-中,会在流水线中一直携带这些信号穿过执行和访存阶段,直到写回阶段才送到寄存器文件(如各个阶段的详细描述所示).我们这样做是为了确保写端口的地址和数据输入是来自同一条指令.否则,会将处于写回阶段的指令的值写入,而寄存器ID却来自于处于译码阶段的指令.作为一条通用原则,我们要保存处于一个流水线阶段中的指令的所有信息

PIPE-中有一个块在相同表示形式的SEQ+中是没有的,那就是译码阶段中标号为"Select A"的块.我们可以看出,这个块会从来自流水线寄存器D的valP或从寄存器文件A端口中读出的值中选择一个,作为流水线寄存器E的值valA,包括这个块是为了减少要携带给流水线寄存器E和M的状态数量.在所有的指令中,只有call在访存阶段需要valP的值.只有跳转指令在执行阶段(当不需要进行跳转时)需要valP的值.而这些指令又都不需要从寄存器文件中读出的值.因此我们合并这两个信号,将它们作为信号valA携带穿过流水线,从而可以减少流水线寄存器的状态数量.这样做就消除了SEQ和SEQ+中标号为"Data"的块,这个块完成的是类似的功能.==在硬件设计中,像这样仔细确认信号是如何使用的,然后通过合并信号来减少寄存器状态和线路的数量,是很常见的==

### 预测下一个PC

在PIPE-设计中,我们采取了一些措施来正确处理控制相关.流水线化设计的目的就是每个时钟周期都发射一条新指令,也就是说每个时钟周期都有一条新指令进入执行阶段并最终完成.要是达到这个目的也就意味着吞吐量是每个时钟周期一条指令.要做到这一点,我们必须在取出当前指令之后,马上确定下一条指令的位置.不幸的是,如果取出的指令是条件分支指令,要到几个周期后,也就是指令通过执行阶段之后,我们才能知道是否要选择分支.类似地,如果取出的指令是ret,要到指令通过访存阶段,才能确定返回地址

除了条件转移指令和ret以外,根据取指阶段中计算出的信息,我们能够确定下一条指令的地址.对于call和jmp(无条件转移)来说,下一条指令的地址是指令中的常数字valc,而对于其他指令来说就是va1P,因此,通过预测PC的下一个值,在大多数情况下,我们能达到每个时钟周期发射一条新指令的目的.对大多数指令类型来说,我们的预测是完全可靠的.对条件转移来说,我们既可以预测选择了分支,那么新PC值应为valc,也可以预测没有选择分支,那么新PC值应为valP,无论哪种情况,我们都必须以某种方式来处理预测错误的情况,因为此时已经取出并部分执行了错误的指令

猜测分支方向并根据猜测开始取指的技术称为==分支预测==.实际上所有的处理器都采用了某种形式的此类技术

> 使用栈的返回地址预测
>
> 对大多数程序来说,预测返回值很容易,因为过程调用和返回是成对出现的.大多数函数调用,会返回到调用后的那条指令.高性能处理器中运用了这个属性,在取指单元中放入一个硬件栈,保存过程调用指令产生的返回地址.每次执行过程调用指令时,都将其返回地址压入栈中.当取出一个返回指令时,就从这个栈中弹出顶部的值,作为预测的返回值.同分支预测一样,在预测错误时必须提供一个恢复机制,因为还是有调用和返回不匹配的时候.通常,这种预测很可靠.这个硬件栈对程序员来说是不可见的

### 流水线冒险

1. 数据相关,下一条指令会用到这一条指令计算出的结果
2. 控制相关,一条指令要确定下一条指令的位置,例如在执行跳转、调用或返回指令时.这些相关可能会导致流水线产生计算错误,称为冒险(hazard),同相关一样,冒险也可以分为两类:数据冒险(data hazard)和控制冒险(control hazard).我们首先关心的是数据冒险,然后再考虑控制冒险

![image-20210708144643419](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708144643419.png)

![image-20210708150630464](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708150630464.png)

![image-20210708150806768](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708150806768.png)

![image-20210708150942200](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708150942200.png)

#### 数据冒险的类型

##### 程序寄存器

出现这种冒险是因为寄存器文件的读写是在不同的阶段进行的,导致不同指令之间可能出现不希望的相互作用

##### 程序计数器

更新和读取程序计数器之间的冲突导致了控制冒险.当我们的取指阶段逻辑在取下一条指令之前,正确预测了程序计数器的新值时,就不会产生冒险

##### 内存

对数据内存的读和写都发生在访存阶段.在一条读内存的指令到达这个阶段之前,前面所有要写内存的指令都已经完成这个阶段了.另外,在访存阶段中写数据的指令和在取指阶段中读指令之间也有冲突,因为指令和数据内存访问的是同一个地址空间.只有包含自我修改代码的程序才会发生这种情况,在这样的程序中,指令写内存的一部分,过后会从中取出指令.有些系统有复杂的机制来检测和避免这种冒险,而有些系统只是简单地强制要求程序不应该使用自我修改代码.为了简便,假设程序不能修改自身,因此我们不需要采取特殊的措施,根据在程序执行过程中对数据内存的修改来修改指令内存

##### 条件码寄存器

在执行阶段中,整数操作会写这些寄存器.条件传送指令会在执行阶段以及条件转移会在访存阶段读这些寄存器.在条件传送或转移到达执行阶段之前,前面所有的整数操作都已经完成这个阶段了.所以不会发生冒险

##### 状态寄存器

指令流经流水线的时候,会影响程序状态.我们采用流水线中的每条指令都与一个状态码相关联的机制,使得当异常发生时,处理器能够有条理地停止

#### 处理方法

##### 用暂停来避免数据冒险

暂停(stalling)是避免冒险的一种常用技术,暂停时,处理器会停止流水线中一条或多条指令,直到冒险条件不再满足.让一条指令停顿在译码阶段,直到产生它的源操作数的指令通过了写回阶段,这样我们的处理器就能避免数据冒险

暂停技术就是让一组指令阻塞在它们所处的阶段,而允许其他指令继续通过流水线.使用的处理方法是:每次要把一条指令阻塞在译码阶段,就在执行阶段插入一个气泡.气泡就像一个自动产生的nop指令,它不会改变寄存器、内存、条件码或程序状态

![image-20210708153556780](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708153556780.png)

![image-20210708153441638](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708153441638.png)

##### 用转发来避免数据冒险

PIPE-的设计是在译码阶段从寄存器文件中读入源操作数,但是对这些源寄存器的写有可能要在写回阶段才能进行.与其暂停直到写完成,不如简单地将要写的值传到流水线寄存器E作为源操作数.译码阶段逻辑发现,寄存器%rax是操作数valB的源寄存器,而在写端口E上还有一个对%rax的未进行的写.它只要简单地将提供到端口E的数据字(信号w_valE)作为操作数valB的值,就能避免暂停.==这种将结果值直接从一个流水线阶段传到较早阶段的技术称为数据转发(data forwarding,或简称转发,有时称为旁路(bypassing)==)

![image-20210708160144230](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708160144230.png)

![image-20210708160728349](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708160728349.png)

为了充分利用数据转发技术,我们还可以将新计算出来的值从执行阶段传到译码阶段,以避免程序所需要的暂停,如图所示.在周期4中,译码阶段逻辑发现在访存阶段中有对寄存器%rdx未进行的写,而且执行阶段中ALU正在计算的值稍后也会写入寄存器%rax,它可以将访存阶段中的值(信号M_valE)作为操作数valA,也可以将ALU的输出(信号e_vale)作为操作数valB,注意,使用ALU的输出不会造成任何时序问题.译码阶段只要在时钟周期结束之前产生信号valA和valB,这样在时钟上升开始下一个周期时,流水线寄存器E就能装载来自译码阶段的值了.而在此之前ALU的输出已经是合法的了

![image-20210708160741525](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708160741525.png)



#### 流水线化的最终实现硬件结构

![image-20210708161205507](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708161205507.png)

#### 加载/使用数据冒险

有一类数据冒险不能单纯用转发来解决,因为内存读在流水线发生的比较晚

![image-20210708190200393](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708190200393.png)

可以将暂停和转发结合起来,避免加载/使用数据冒险.这个需要修改控制逻辑,但是可以使用现有的旁路路径.当mrmovq指令通过执行阶段时,流水线控制逻辑发现译码阶段中的指令(addq)需要从内存中读出的结果.它会将译码阶段中的指令暂停一个周期,导致执行阶段中插入一个气泡

![image-20210708190729483](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210708190729483.png)

这种用暂停来处理加载/使用冒险的方法称为==加载互锁(load interlock)==.加载互锁和转发技术结合起来足以处理所有可能类型的数据冒险.因为只有加载互锁会降低流水线的吞吐量,我们几乎可以实现每个时钟周期发射一条新指令的吞吐量目标

#### 避免控制冒险

当处理器无法根据处于取指阶段的当前指令来确定下一条指令的地址时,就会出现控制冒险.在流水线化处理器中,控制冒险只会发生在ret指令和跳转指令.而且,后一种情况只有在条件跳转方向预测错误时才会造成麻烦

对控制冒险的讨论表明,通过慎重考虑流水线的控制逻辑,控制冒险是可以被处理的.在出现特殊情况时,暂停和往流水线中插入气泡的技术可以动态调整流水线的流程.对基本时钟寄存器设计的简单扩展就可以让我们暂停流水段,并向作为流水线控制逻辑一部分的流水线寄存器中插入气泡

### 异常处理

处理器中很多事情都会导致异常控制流,此时,程序执行的正常流程被破坏掉.异常可以由程序执行从内部产生,也可以由某个外部信号从外部产生.指令集体系结构包括三种不同的内部产生的异常: 

1. halt指令
2. 有非法指令和功能码组合的指令
3. 取指或数据读写试图访问一个非法地址

一个更完整的处理器设计应该也能处理外部异常.正确处理异常是任何微处理器设计中很有挑战性的一方面.异常可能出现在不可预测的时间,需要明确地中断通过处理器流水线的指令流

我们把导致异常的指令称为==异常指令(excepting instruction)==.在使用非法指令地址的情况中,没有实际的异常指令,但是想象在非法地址处有一种“虚拟指令”会有所帮助.在简化的ISA模型中,我们希望当处理器遇到异常时,会停止设置适当的状态码.看上去应该是到异常指令之前的所有指令都已经完成,而其后的指令都不应该对程序员可见的状态产生任何影响.在一个更完整的设计中,处理器会继续调用异常处理程序(exception handler),这是操作系统的一部分

在一个流水线化的系统中,异常处理包括一些细节问题

* 首先,可能同时有多条指令会引起异常.我们必须确定处理器应该向操作系统报告哪个异常.==基本原则是:由流水线中最深的指令引起的异常,优先级最高==

* 第二个细节问题是,当首先取出一条指令,开始执行时,导致了一个异常,而后来日于分支预测错误,取消了该指令
* 第三个细节问题的产生,是因为流水线化的处理器会在不同的阶段更新系统状态的不同部分.有可能会出现这样的情况,一条指令导致了一个异常,它后面的指令在异常指令完成之前改变了部分状态

一般地,通过在流水线结构中加入异常处理逻辑,我们既能够从各个异常中做出正确的选择,也能够避免出现由于分支预测错误取出的指令造成的异常.这就是为什么我们会在每个流水线寄存器中包括一个状态码stat.如果一条指令在其处理中于某个阶段产生了一个异常,这个状态字段就被设置成指示异常的种类.异常状态和该指令的其他信息一起沿着流水线传播,直到它到达写回阶段.在此,流水线控制逻辑发现出现了异常,并停止执行

为了避免异常指令之后的指令更新任何程序员可见的状态,当处于访存或写回阶段中的指令导致异常时,流水线控制逻辑必须禁止更新条件码寄存器或是数据内存

当流水线中有一个或多个阶段出现异常时,信息只是简单地存放在流水线寄存器的状态字段中.异常事件不会对流水线中的指令流有任何影响,除了会禁止流水线中后面的指令更新程序员可见的状态(条件码寄存器和内存),直到异常指令到达最后的流水线阶段.因为指令到达写回阶段的顺序与它们在非流水线化的处理器中执行的顺序相同,所以我们可以保证第一条遇到异常的指令会第一个到达写回阶段,此时程序执行会停止,流水线寄存器W中的状态码会被记录为程序状态.如果取出了某条指令,过后又取消了,那么所有关于这条指令的异常状态信息也都会被取消.所有导致异常的指令后面的指令都不能改变程序员可见的状态.携带指令的异常状态以及所有其他信息通过流水线的简单原则是处理异常的简单而可靠的机制

### PIPE各阶段的实现

==PIPE是使用了转发技术的流水线化的Y86-64处理器==.它使用了一组与前面顺序设计相同的硬件单元,另外增加了一些流水线寄存器、一些重新配置了的逻辑块,以及增加的流水线控制逻辑

许多逻辑块与SEQ和SEQ+中相应部件完全相同,除了我们必须从来自不同流水线寄存器(用大写的流水线寄存器的名字作为前缀)或来自各个阶段计算(用小写的阶段名字的第一个字母作为前缀)的信号中选择适当的值

#### PC选择和取指阶段

![image-20210709102143032](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709102143032.png)

PC选择逻辑从三个程序计数器源中进行选择.当一条预测错误的分支进入访存阶段时,会从流水线寄存器M(信号M_valA)中读出该指令valP的值(指明下一条指令的地址).当ret指令进入写回阶段时,会从流水线寄存器W(信号W_valM)中读出返回地址

同SEQ中不一样,我们必须将指令状态的计算分成两个部分.在取指阶段,可以测试由于指令地址越界引起的内存错误,还可以发现非法指令或halt指令.必须推迟到访存阶段才能发现非法数据地址

#### 译码和写回阶段

![image-20210709102800738](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709102800738.png)

标号为"dstE"、 "dstM"、"srcA"和“srcB"的块非常类似于它们在SEQ的实现中的相应部件.=提供给写端口的寄存器ID来自于写回阶段(信号w_dstE和w_dstM),而不是来自于译码阶段=.这是因为我们希望进行写的目的寄存器是由写回阶段中的指令指定的

这个阶段的复杂性主要是跟转发逻辑相关.就像前面提到的那样,标号为"Sel+FwdA"的块扮演两个角色.它为后面的阶段将valP信号合并到valA信号,这样可以减少流水线寄存器中状态的数量.它还实现了源操作数valA的转发逻辑

合并信号valA和valP的依据是,只有call和跳转指令在后面的阶段中需要valP的值,而这些指令并不需要从寄存器文件A端口中读出的值.这个选择是由该阶段的icode信号来控制的.当信号D_icode与call或jXX的指令代码相匹配时,这个块就会选择D_valP作为它的输出

有5个不同的转发源,每个都有一个数据字和一个目的寄存器ID:

![image-20210709104209876](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709104209876.png)

上述HCL代码中赋予这5个转发源的优先级是非常重要的.==这种优先级是由HCL代码中检测5个目的寄存器ID的顺序来确定的==.如果选择了其他任何顺序,对某些程序来说,流水线就会出错.==要求对执行和访存阶段中的转发源设置正确的优先级==

![image-20210709110818741](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709110818741.png)

写回阶段的一小部分是保持不变的.整个处理器的状态stat是一个块根据流水线寄存器w中的状态值计算出来的.由于流水线寄存器w保存着最近完成的指令的状态,很自然地要用这个值来表示整个处理器状态.唯一要考虑的特殊情况是当写回阶段有气泡时.这是正常操作的一部分,因此对于这种情况,我们也希望状态码是AOK

#### 执行阶段

![image-20210709111428451](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709111428451.png)

这些硬件单元和逻辑块同SEQ中的相同,使用的信号做适当的重命名.我们可以看到信号e-valE和e-dstE作为转发源,指向译码阶段.一个区别是标号为"Set CC"的逻辑以信号m stat和w-stat作为输入,这个逻辑决定了是否要更新条件码.这些信号被用来检查一条导致异常的指令正在通过后面的流水线阶段的情况,因此,任何对条件码的更新都会被禁止

#### 访存阶段

![image-20210709113724105](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709113724105.png)

将这个逻辑与SEQ的访存阶段相比较,我们看到,正如前面提到的那样, PIPE中没有SEQ中标号为"Data"的块.这个块是用来在数据源valP(对call指令来说)和valA中进行选择的,但是这个选择现在由译码阶段中标号为"Sel+Fwd A"的块来执行.这个阶段中的其他块都和SEQ中相应的部件相同,采用的信号做适当的重命名.在图中,你还可以看到许多流水线寄存器M和w中的值作为转发和流水线控制逻辑的一部分,提供给电路中其他部分

### 流水线控制逻辑

加载/使用冒险:在一条从内存中读出一个值的指令和一条使用该值的指令之间,流水线必须暂停一个周期

处理ret:流水线必须暂停直到ret指令到达写回阶段

预测错误的分支:在分支逻辑发现不应该选择分支之前,分支目标处的几条指令已经进入流水线了.必须取消这些指令,并从跳转指令后面的那条指令开始取指

异常:当一条指令导致异常,我们想要禁止后面的指令更新程序员可见的状态,并且在异常指令到达写回阶段时,停止执行

#### 特殊控制情况所期望的处理

* 对加载/使用冒险所期望的流水线操作,只有mrmovq和popq指令会从内存中读数据.当这两条指令中的任一条处于执行阶段,并且需要该目的寄存器的指令正处在译码阶段时,我们要将第二条指令阻塞在译码阶段,并在下一个周期往执行阶段中插入一个气泡.此后,转发逻辑会解决这个数据冒险.可以将流水线寄存器D保持为固定状态,从而将一个指令阻塞在译码阶段.这样做还可以保证流水线寄存器F保持为固定状态,由此下一条指令会被再取一次.总之,实现这个流水线流需要发现冒险的情况,保持流水线寄存器F和D固定不变,并且在执行阶段中插入气泡
* 对ret指令的处理,流水线要停顿3个时钟周期,直到ret指令经过访存阶段,读出返回地址
* 当分支预测错误发生时,跳转指令到达执行阶段时就可以检测到预测错误.然后在下一个时钟周期,控制逻辑就会在译码和执行段插入气泡,取消两条不正确的已取指令.在同一个时钟周期,流水线将正确的指令读取到取指阶段.对于导致异常的指令,我们必须使流水线化的实现符合期望的ISA行为,也就是在前面所有的指令结束前,后面的指令不能影响程序的状态.一些因素会使得想达到这些效果比较麻烦: 1)异常在程序执行的两个不同阶段(取指和访存)被发现的, 2)程序状态在三个不同阶段(执行、访存和写回)被更新
* 每个流水线寄存器中会包含一个状态码stat,随着每条指令经过流水线阶段,它会记录指令的状态.当异常发生时,我们将这个信息作为指令状态的一部分记录下来,并且继续取指、译码和执行指令,就好像什么都没有出错似的.当异常指令到达访存阶段时,我们会采取措施防止后面的指令修改程序员可见的状态: 1)禁止执行阶段中的指令设置条件码, 2)向内存阶段中插入气泡,以禁止向数据内存中写入,3)当写回阶段中有异常指令时,暂停写回阶段,因而暂停了流水线

#### 发现特殊控制条件

![image-20210709142535327](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709142535327.png)

#### 流水线控制机制

假设每个流水线寄存器有两个控制输入:暂停(stall)和气泡(bubble),这些信号的设置决定了当时钟上升时该如何更新流水线寄存器.在正常操作下,这两个输入都设为0,使得寄存器加载它的输入作为新的状态.当暂停信号设为1时,禁止更新状态.相反,寄存器会保持它以前的状态.这使得它可以将指令阻塞在某个流水线阶段中.当气泡信号设置为1时,寄存器状态会设置成某个固定的复位配置(resetconfiguration),得到一个等效于nop指令的状态.一个流水线寄存器的复位配置的0、1模式是由流水线寄存器中字段的集合决定的.例如,要往流水线寄存器D中插入一个气泡,我们要将icode字段设置为常数值INOP.要往流水线寄存器E中插入一个气泡,我们要将icode字段设为INOP,并将dstE, dstM, srcA和srcB字段设为常数RNONE.我们会将气泡和暂停信号都设为1看成是出错

![image-20210709142908594](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709142908594.png)

![image-20210709143819603](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709143819603.png)

#### 控制条件的组合

在设计系统时,一个常见的缺陷是不能处理同时出现多个特殊情况的情形.加载/使用冒险要求执行阶段中的指令将一个值从内存读到寄存器中,同时译码阶段中的指令要以该寄存器作为源操作数.预测错误的分支要求执行阶段中的指令是一个跳转指令.对ret来说有三种可能的情况-指令可以处在译码、执行或访存阶段.当ret指令通过流水线时,前面的流水线阶段都是气泡

![image-20210709152845712](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709152845712-1625815726323.png)

大多数控制条件是互斥的.例如,不可能同时既有加载/使用冒险又有预测错误的分支,因为加载/使用冒险要求执行阶段中是加载指令(mrmovq或popq),而预测错误的分支要求执行阶段中是一条跳转指令.类似地,第二个和第三个ret组合也不可能与加载/使用冒险或预测错误的分支同时出现.只有用箭头标明的两种组合可能同时出现

![image-20210709153034318](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709153034318.png)

合并组合B条件的控制动作,得到以下流水线控制动作:

![image-20210709154213153](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709154213153.png)

#### 控制逻辑实现

根据来自流水线寄存器和流水线阶段的信号,控制逻辑产生流水线寄存器的暂停和气泡控制信号,同时也决定是否要更新条件码寄存器

![image-20210709154448913](%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F.assets/image-20210709154448913.png)

> 测试设计
>
> 正如我们看到的,即使是对于一个很简单的微处理器,设计中还是有很多地方会出现问题.使用流水线处于不同流水线阶段的指令之间有许多不易察觉的交互.我们看到一些设计上的挑战来自于不常见的指令(例如弹出值到栈指针),或是不常见的指令组合(例如不选择分支的跳转指令后面跟一条ret指令).还看到异常处理增加了一类全新的可能的流水线行为.那么怎样确定我们的设计是正确的呢?对于硬件制造者来说,这是主要关心的问题,因为他们不能简单地报告一个错误,让用户通过Internet下载代码补丁.即使是简单的逻辑设计错误都可能有很严重的后果,特别是随着微处理器越来越多地用于对我们的生命和健康至关重要的系统的运行中,例如汽车防抱死制动系统、心脏起搏器以及航空控制系统.简单地模拟设计运行一些“典型的”程序,不足以用来测试一个系统.相反,全面的测试需要设计一些方法,系统地产生许多测试尽可能多地使用不同指令和指令组合
>
> 在创建Y86-64处理器的过程中,我们还设计了很多测试脚本,每个脚本都产生出很多不同的测试运行处理器模拟,并且比较得到的寄存器和内存值和我们YIS指令集模拟器产生的值.
>
> 以下是这些脚本的简要介绍:
>
> * optest:运行49个不同的Y86-64指令测试,具有不同的源和目的寄存器
> * jtest:运行64个不同的跳转和函数调用指令的测试,具有不同的是否选择分支的组合
> * mtest:运行28个不同的条件传送指令的测试,具有不同的控制组合
> * htest:运行600个不同的数据冒险可能性的测试,具有不同的源和目的的指令的组合,在这些指令对之间有不同数量的nop指令
> * ctest : 测试22个不同的控制组合
> * etest:测试12种不同的导致异常的指令和跟在后面可能改变程序员可见状态的指令组合
>
> 这种测试方法的关键思想是我们想要尽量的系统化,生成的测试会创建出不同的可能导致流水线错误的条件

> 形式化地验证我们的设计
>
> 即使一个设计通过了广泛的测试,我们也不能保证对于所有可能的程序,它都能正确运行.即使只考虑由短的代码段组成的测试,可以测试的可能的程序的数量也大得难以想象.不过,形式化验证(formal verification)的新方法能够保证有工具能够严格地考虑一个系统所有可能的行为,并确定是否有设计错误.,我们能够形式化验证Y86-64处理器较早的一个版本.建立一个框架,比较流水线化的设计PIPE和非流水线化的版本SEQ,也就是,它能够证明对于任意Y86-64程序,两个处理器对程序员可见的状态有完全一样的影响.当然,我们的验证器不可能真的运行所有可能的程序,因为这样的程序的数量是无穷大的.相反,它使用了归纳法来证明,表明两个处理器之间在一个周期到一个周期的基础上都是一致的.进行这种分析要求用符号方法(symbolic methods)来推导硬件,在符号方法中,我们认为所有的程序值都是任意的整数,将ALU抽象成某种“黑盒子”,根据它的参数计算某个未指定的函数.我们只假设SEQ和PIPE的ALU计算相同的函数
>
> 用控制逻辑的HCL描述来产生符号处理器模型的控制逻辑, 因此我们能发现HCI代码中的问题.能够证明SEQ和PIPE是完全相同的,也不能保证它们忠实地实现了Y86-64指令集体系结构.不过,它能够发现任何由于不正确的流水线设计导致的错误,这是设计错误的主要来源

> 流水线化的Y86-64处理器的Verilog实现
>
> 现代的逻辑设计包括用硬件描述语言书写硬件设计的文本表示.然后,可以通过模拟和各种形式化验证工具来测试设计.一旦对设计有了信心,我们就可以使用逻辑合成(logic synthesis)工具将设计翻译成实际的逻辑电路.我们用Verilog硬件描述语言开发了Y86-64处理器设计的模型.这些设计将实现处理器基本构造块的模块和直接从HCI描述产生出来的控制逻辑结合了起来.我们能够合成这些设计的一些,将逻辑电路描述下载到字段可编程的门阵列(FPGA)硬件上,可以在这些处理器上运行实际的Y86-64程序

### 性能分析

所有需要流水线控制逻辑进行特殊处理的条件,都会导致流水线不能够实现每个时钟周期发射一条新指令的目标.==我们可以通过确定往流水线中插入气泡的频率,来衡量这种效率的损失,因为插入气泡会导致未使用的流水线周期==.一条返回指令会产生三个气泡,一个加载/使用冒险会产生一个,而一个预测错误的分支会产生两个.我们可以通过计算PIPE执行一条指令所需要的平均时钟周期数的估计值,来量化这些处罚对整体性能的影响,这种衡量方法称为CPI(Cycles Per Instruction,每指令周期数).这种衡量值是流水线平均吞吐量的倒数,不过时间单位是时钟周期,而不是微微秒.这是一个设计体系结构效率的很有用的衡量标准.如果我们忽略异常带来的性能损失(异常的定义表明它是很少出现的),另一种思考CPI的方法是,假设我们在处理器上运行某个基准程序,并观察执行阶段的运行.每个周期,执行阶段要么会处理一条指令,然后这条指令继续通过剩下的阶段,直到完成;要么会处理个由于三种特殊情况之一而插入的气泡.如果这个阶段一共处理了$C_i$条指令和$C_b$个气泡,那么处理器总共需要大约$C_i+C_b$个时钟周期来执行$C_i$条指令.我们说“大约”是因为忽路了启动指令通过流水线的周期.于是,可以用如下方法来计算这个基准程序的CPI
$$
CPI=\frac{C_i+C_b}{C_i}=1.0+\frac{C_b}{C_i}
$$
也就是说, CPI等于1.0加上一个处罚项$\frac{C_b}{C_i}$,这个项表明执行一条指令平均要插入多少个气泡.因为只有三种指令类型会导致插入气泡,我们可以将这个处罚项分解成三个部分
$$
CPI=1.0+lp+mp+rp
$$
这里, lp(load penalty,加载处罚)是当由于加载/使用冒险造成暂停时插入气泡的平均数, mp(mispredicted branch penalty,预测错误分支处罚)是当由于预测错误取消指令时插入气泡的平均数,而rp(return penalty,返回处罚)是当由于ret指令造成暂停时插人气泡的平均数.每种处罚都是由该种原因引起的插入气泡的总数(CG的一部分)除以执行指令的总数($C_i$)

### 未完成的工作

#### 多周期指令

Y86-64指令集中的所有指令都包括一些简单的操作,例如数字加法.这些操作可以在执行阶段中一个周期内处理完.在一个更完整的指令集中,我们还将实现一些需要更为复杂操作的指令,例如,整数乘法和除法,以及浮点运算.在一个像PIPE这样性能中等的处理器中,这些操作的典型执行时间从浮点加法的3或4个周期到整数除法的64个周期.为了实现这些指令,我们既需要额外的硬件来执行这些计算,还需要一种机制来协调这些指令的处理与流水线其他部分之间的关系

实现多周期指令的一种简单方法就是简单地扩展执行阶段逻辑的功能,添加一些整数和浮点算术运算单元.一条指令在执行阶段中逗留它所需要的多个时钟周期,会导致取指和译码阶段暂停.这种方法实现起来很简单,但是得到的性能并不是太好

通过采用独立于主流水线的特殊硬件功能单元来处理较为复杂的操作,可以得到更好的性能.通常,有一个功能单元来执行整数乘法和除法,还有一个来执行浮点操作.当一条指令进入译码阶段时,它可以被发射到特殊单元.在这个特殊单元执行该操作时,流水线会继续处理其他指令.通常,浮点单元本身也是流水线化的,因此多条指令可以在主流水线和各个单元中并发执行.不同单元的操作必须同步,以避免出错.比如说,如果在不同单元执行的各个指令之间有数据相关,控制逻辑可能需要暂停系统的某个部分,直到由系统其他某个部分处理的操作的结果完成.经常使用各种形式的转发,将结果从系统的一个部分传递到其他部分,这和前面PIPE各个阶段之间的转发一样.虽然与PIPE相比,整个设计变得更为复杂,但还是可以使用暂停、转发以及流水线控制等同样的技术来使整体行为与顺序的ISA模型相匹配

#### 与存储系统的接口

在对PIPE的描述中,我们假设取指单元和数据内存都可以在一个时钟周期内读或是写内存中任意的位置.我们还忽略了由自我修改代码造成的可能冒险,在自我修改代码中,一条指令对一个存储区域进行写,而后面又从这个区域中读取指令.进一步说,我们是以存储器位置的虚拟地址来引用它们的,这要求在执行实际的读或写操作之前,要将虚拟地址翻译成物理地址.显然,要在一个时钟周期内完成所有这些处理是不现实的.更糟糕的是,要访问的存储器的值可能位于磁盘上,这会需要上百万个时钟周期才能把数据读人到处理器内存中.

处理器的存储系统是由多种硬件存储器和管理虚拟内存的操作系统软件共同组成的.存储系统被组织成一个层次结构,较快但是较小的存储器保持着存储器的一个子集,而较慢但是较大的存储器作为它的后备.最靠近处理器的一层是高速缓存(cache)存储器,它提供对最常使用的存储器位置的快速访问.一个典型的处理器有两个第一层高速缓存–一个用于读指令,一个用于读和写数据.另一种类型的高速缓存存储器,称为翻译后备缓冲器(Translation Look-aside Buffer, TLB),它提供了从虚拟地址到物理地址的快速翻译.将TLB和高速缓存结合起来使用,在大多数时候,确实可能在一个时钟周期内读指令并读或是写数据.因此,我们的处理器对访问存储器的简化看法实际上是很合理的

虽然高速缓存中保存有最常引用的存储器位置,但是有时候还会出现高速缓存不命中(miss),也就是有些引用的位置不在高速缓存中.在最好的情况中,可以从较高层的高速缓存或处理器的主存中找到不命中的数据,这需要3~20个时钟周期.同时,流水线会简单地暂停,将指令保持在取指或访存阶段,直到高速缓存能够执行读或写操作.至于流水线设计,通过添加更多的暂停条件到流水线控制逻辑,就能实现这个功能.高速缓存不命中以及随之而来的与流水线的同步都完全是由硬件来处理的,这样能使所需的时间尽可能地缩短到很少数量的时钟周期

在有些情况中,被引用的存储器位置实际上是存储在磁盘存储器上的.此时,硬件会产生一个缺页(page fault)异常信号.同其他异常一样,这个异常会导致处理器调用操作系统的异常处理程序代码.然后这段代码会发起一个从磁盘到主存的传送操作.一旦完成,操作系统会返回到原来的程序,而导致缺页的指令会被重新执行.这次,存储器引用将成功,虽然可能会导致高速缓存不命中.让硬件调用操作系统例程,然后操作系统例程又会将控制返回给硬件,这就使得硬件和系统软件在处理缺页时能协同工作.因为访问磁盘需要数百万个时钟周期, OS缺页中断处理程序执行的处理所需的几百个时钟周期对性能的影响可以忽略不计

从处理器的角度来看,将用暂停来处理短时间的高速缓存不命中和用异常处理来处理长时间的缺页结合起来,能够顾及到存储器访问时由于存储器层次结构引起的所有不可预测性

# 优化程序性能

写程序最主要的目标就是使它在所有可能的情况下都正确工作.一个运行得很快但是给出错误结果的程序没有任何用处.程序员必须写出清晰简洁的代码,这样做不仅是为了自己能够看懂代码,也是为了在检查代码和今后需要修改代码时,其他人能够读懂和理解代码

另一方面,在很多情况下,让程序运行得快也是一个重要的考虑因素.如果一个程序要实时地处理视频帧或者网络包,一个运行得很慢的程序就不能提供所需的功能.当一个计算任务的计算量非常大,需要执行数日或者数周,那么哪怕只是让它运行得快20%也会产生重大的影响

# 参考

* 深入理解计算机系统(原书第三版)

