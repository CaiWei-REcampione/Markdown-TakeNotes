# **计算机：辅助人脑的好工具**

## 计算机硬件的五大单元

关于计算机的硬件组成部分，其实你可以观察你的桌面计算机来分析一下，依外观来说这家伙主要可分为三部分，分别是：

*    输入单元：包括键盘、鼠标、卡片阅读机、扫描仪、手写板、触控屏幕等等一堆；
*    主机部分：这个就是系统单元，被主机机壳保护住了，里面含有一堆板子、CPU 与主存储器等；
*    输出单元：例如屏幕、打印机等等

整部主机的重点在于中央处理器 (Central Processing Unit, CPU)，CPU 为一个具有特定功能的芯片， 里头含有<u>微指令集</u>，如果你想要让主机进行什么特异的功能，就得要参考这颗 CPU 是否有相关内建的微指令集才可以。

综合上面所说的，我们会知道其实计算机是由几个单元所组成的，包括<u>输入单元、 输出单元、CPU 内部的控制单元、算数逻辑单元与主存储器五大部分</u>。

## 一切设计的起点： CPU 的架构

### **精简指令集 (Reduced Instruction Set Computer, RISC)**

这种 CPU 的设计中，<u>微指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳； 但是若要做复杂的事情，就要由多个指令来完成</u>。

CPU 主要例如甲骨文 (Oracle) 公司的 SPARC 系列、 IBM 公司的 Power Architecture (包括 PowerPC) 系列、与安谋公司 (ARM Holdings) 的 ARM CPU 系列等。

目前世界上使用范围最广的 CPU 可能就是 ARM 这种架构

### **复杂指令集(Complex Instruction Set Computer, CISC)**

CISC 在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂， 每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长， 但每条个别指令可以处理的工作较为丰富。

常见的 CISC 微指令集 CPU 主要有 AMD、Intel、VIA 等的 x86 架构的 CPU。

### 位

所谓的位指的是CPU 一次数据读取的最大量

64 位CPU 代表 CPU 一次可以读写 64bits这么多的数据，32 位 CPU 则是 CPU 一次只能读取 32 位的意思。 

因为 CPU 读取数据量有限制，因此能够从内存中读写的数据也就有所限制。

## 计算机上面常用的计算单位 (容量、速度等)

### **容量单位**

计算机对数据的判断主要依据有没有通电来记录信息，所以理论上对于每一个纪录单位而言，它只认识 0 与 1 而已。0/1 这个二进制的的单位我们称为 bit。

1 Byte = 8 bits

| 进位制 | Kilo | Mega  | Giga  | Tera  | Peta  | Exa   | Zetta |
| ------ | ---- | ----- | ----- | ----- | ----- | ----- | ----- |
| 二进制 | 1024 | 1024K | 1024M | 1024G | 1024T | 1024P | 1024E |
| 十进制 | 1000 | 1000K | 1000M | 1000G | 1000T | 1000P | 1000E |

### **速度单位**

CPU 的指令周期常使用 MHz 或者是 GHz 之类的单位，这个 Hz 其实就是秒分之一。

而在网络传输方面，由于网络使用的是 bit 为单位，因此网络常使用的单位为 Mbps 是 Mbits per second，亦即是每秒多少 Mbit。

## **个人计算机架构与相关设备组件**

### 南北桥

#### 北桥

负责链接速度较快的 CPU、主存储器与显示适配器界面等组件

不过由于北桥最重要的就是 CPU 与主存储器之间的桥接，<u>因此目前的主流架构中， 大多将北桥内存控制器整合到 CPU 封装当中了</u>。

#### 南桥

负责连接速度较慢的装置接口， 包括硬盘、USB、网络卡等等。

### 执行脑袋运算与判断的 CPU

目前(2015)主流的 CPU 都是双核以上的架构了！原本的单核心 CPU 仅有一个运算单元，所谓的多核心则是在一颗 CPU 封装当中嵌入了两个以上的运算核心， 简单的说，就是一个实体的 CPU 外壳中，含有两个以上的 CPU 单元就是了。

不同的微指令集会导致 CPU 工作效率的优劣。

频率就是 CPU 每秒钟可以进行的工作次数。 所以频率越高表示这颗 CPU 单位时间内可以作更多的事情。

#### **CPU** **的工作频率：外频与倍频**

因为所有的设备都得掉透过北桥来连结，因此每个设备的工作频率应该要相同。

但因为 CPU 的指令周期比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。

所谓的外频指的是 CPU 与外部组件进行数据传输时的速度，倍频则是 CPU 内部用来加速工作效能的一个倍数， 两者相乘才是 CPU 的频率速度。

#### **32** **位与** **64** **位的** **CPU** **与总线『宽度』**

CPU 每次能够处理的数据量称为字组大小(word size)， 字组大小依据 CPU 的设计而有 32 位与 64 位。我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的。

#### **CPU** **等级**

由于 x86 架构的 CPU 在 Intel 的 Pentium 系列(1993 年)后就有不统一的脚位与设计，为了将不同种类的 CPU 规范等级，所以就有 i386,i586,i686 等名词出现了。

#### **超线程** **(Hyper-Threading, HT)**

在每一个 CPU 内部将重要的缓存器 (register) 分成两群， 而让程序分别使用这两群缓存器。也就是说，可以有两个程序『同时竞争 CPU 的运算单元』，而非透过操作系统的多任务切换。

### 内存

CPU 所使用的数据都是来自于主存储器(main memory)，不论是软件程序还是数据，都必须要读入主存储器后 CPU 才能利用。 个人计算机的主存储器主要组件为<u>动态随机存取内存</u>(Dynamic Random Access Memory, DRAM)， 随机存取内存只有在通电时才能记录与使用，断电后数据就消失了。因此我们也称这种 RAM 为挥发性内存。

DRAM 根据技术的更新又分好几代，而使用上较广泛的有所谓的 SDRAM 与 DDR SDRAM 两种。

新一代的 PC 大多使用 DDR 内存了。

DDR SDRAM 又依据技术的发展，有 DDR, DDR2, DDR3, DDR4 等等。

####  **多通道设计**

由于所有的数据都必须要存放在主存储器，所以主存储器的数据宽度当然是越大越好。 但传统的总线宽度一般大约仅达 64 位，为了要加大这个宽度，因此芯片组厂商就将两个主存储器汇整在一起，如果一支内存可达 64 位，两支内存就可以达到 128 位了，这就是双通道的设计理念。

#### **DRAM** **与** **SRAM**

最为我们所知的就是CPU 内的第二层高速缓存。 我们现在知道 CPU 的数据都是由主存储器提供，但 CPU 到主存储器之间还是得要透过内存控制器。

如果某些很常用的程序或数据可以放置到 CPU 内部的话，那么 CPU 数据的读取就不需要跑到主存储器重新读取了！

因为第二层快取(L2 cache)整合到 CPU 内部，因此这个 L2 内存的速度必须要 CPU 频率相同。 使用DRAM 是无法达到这个频率速度的，此时就需要静态随机存取内存(Static Random Access Memory,SRAM)的帮忙了。 SRAM 在设计上使用的晶体管数量较多，价格较高，且不易做成大容量，不过由于其速度快， 因此整合到 CPU 内成为高速缓存以加快数据的存取是个不错的方式。

#### 只读存储器(ROM)

BIOS(Basic Input Output System)是一套程序，这套程序是写死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器(Read Only Memory, ROM)。

ROM 是一种非挥发性的内存。另外，BIOS 对于个人计算机来说是非常重要的， 因为他是系统在开机的时候首先会去读取的一个小程序。

BIOS 对计算机系统来讲是非常重要的，因为他掌握了系统硬件的详细信息与开机设备的选择等等。但是计算机发展的速度太快了， 因此 BIOS 程序代码也可能需要作适度的修改才行，所以你才会在很多主板官网找到 BIOS 的更新程序啊！但是 BIOS 原本使用的是无法改写的 ROM ，因此根本无法修正 BIOS 程序代码！为此，现在的 BIOS 通常是写入类似闪存 (flash) 或 EEPROM中。

### 显示适配器

显示适配器又称为 VGA(Video Graphics Array)，他对于图形影像的显示扮演相当关键的角色。

一般对于图形影像的显示重点在于分辨率与颜色深度，因为每个图像显示的颜色会占用掉内存， 因此显示适配器上面会有一个内存的容量，这个显示适配器内存容量将会影响到你的屏幕分辨率与颜色深度。

| 规格         | 宽度     | 速度     | 带宽          |
| ------------ | -------- | -------- | ------------- |
| PCI          | 32  bits | 33  MHz  | 133  MBytes/s |
| PCI  2.2     | 64  bits | 66  MHz  | 533  MBytes/s |
| PCI-X        | 64  bits | 133 MHz  | 1064 MBytes/s |
| AGP  4x      | 32  bits | 66x4 MHz | 1066 MBytes/s |
| AGP  8x      | 32  bits | 66x8 MHz | 2133 MBytes/s |
| PCIe 1.0 x1  | 无       | 无       | 250  MBytes/s |
| PCIe 1.0 x8  | 无       | 无       | 2  GBytes/s   |
| PCIe 1.0 x16 | 无       | 无       | 4  GBytes/s   |

#### 接口

*    D-Sub (VGA 端子)：为较早之前的连接接口，主要为 15 针的连接，为模拟讯号的传输，当初设计是针对传统映像管屏幕而来。 主要的规格有标准的 640x350px @70Hz、1280x1024px @85Hz 及 2048x1536px @85Hz 等。
*    DVI：共有四种以上的接头，不过台湾市面上比较常见的为仅提供数字讯号的 DVI-D，以及整合数字与模拟讯号的 DVI-I 两种。DVI 常见于液晶屏幕的链接， 标准规格主要有： 1920x1200px @60Hz、2560x1600px @60Hz 等。
*    HDMI：相对于 D-sub 与 DVI 仅能传送影像数据，HDMI 可以同时传送影像与声音，因此被广泛的使用于电视屏幕中！计算机屏幕目前也经常都有支持 HDMI 格式！
*    Display port：与 HDMI 相似的，可以同时传输声音与影像。不过这种界面目前在台湾还是比较少屏幕的支持！

### 硬盘与储存设备

计算机系统上面的储存设备包括有：硬盘、软盘、MO、CD、DVD、磁带机、随身碟(闪存)、还有新一代的蓝光光驱等， 乃至于大型机器的局域网络储存设备(SAN, NAS)等等，都是可以用来储存数据的。

#### **硬盘的物理组成**

在硬盘盒里面其实是由许许多多的圆形磁盘盘、机械手臂、 磁盘读取头与主轴马达所组成的

实际的数据都是写在具有磁性物质的磁盘盘上头，而读写主要是透过在机械手臂上的读取头(head)来达成。实际运作时， 主轴马达让磁盘盘转动，然后机械手臂可伸展让读取头在磁盘盘上头进行读写的动作。

#### **磁盘盘上的数据**

由于磁盘盘是圆的，并且透过机器手臂去读写数据，磁盘盘要转动才能够让机器手臂读写。因此，通常数据写入当然就是以圆圈转圈的方式读写

当初设计就是在类似磁盘盘同心圆上面切出一个一个的小区块，这些小区块整合成一个圆形，让机器手臂上的读写头去存取。 这个小区块就是磁盘的最小物理储存单位，称之为<u>扇区</u> (sector)，那同一个同心圆的扇区组合成的圆就是所谓的<u>磁道(track)</u>。 由于磁盘里面可能会有多个磁盘盘，因此在所有磁盘盘上面的同一个磁道可以组合成所谓的<u>磁柱 (cylinder)</u>。

#### **传输界面**

传统磁盘界面包括有 SATA, SAS, IDE 与 SCSI 等等。 若考虑外接式磁盘，那就还包括了 USB, eSATA 等等界面。不过目前 IDE 已经被 SATA 取代，而 SCSI 则被 SAS 取代。

##### **SATA** **界面**

插槽所使用的<u>扁平电缆</u>比较窄小， 而且每个装置需要使用掉一条 SATA 线。因为 SATA 线比较窄小之故，所以对于安装与机壳内的通风都比较好。

| 版本     | 带宽 (Gbit/s) | 速度 (Mbyte/s) |
| -------- | ------------- | -------------- |
| SATA 1.0 | 1.5           | 150            |
| SATA 2.0 | 3             | 300            |
| SATA 3.0 | 6             | 600            |

##### **SAS** **界面**

接口的速度确实比较快。而且还支持例如热拔插等功能，因此，许多的装置连接会以这种接口来链接。

| 版本   | 带宽 (Gbit/s) | 速度 (Mbyte/s) |
| ------ | ------------- | -------------- |
| SAS  1 | 3             | 300            |
| SAS  2 | 6             | 600            |
| SAS 3  | 12            | 1200           |

##### **USB** **界面**

| 版本     | 带宽 (Mbit/s) | 速度 (Mbyte/s) |
| -------- | ------------- | -------------- |
| USB  1.0 | 12            | 1.5            |
| USB  2.0 | 480           | 60             |
| USB  3.0 | 5G            | 500            |
| USB  3.1 | 10G           | 1000           |

##### **固态硬盘** **(Solid State Disk, SSD)**

固态硬盘最大的好处是，它没有马达不需要转动，而是透过内存直接读写的特性，因此除了没数据延迟且快速之外，还很省电。

每秒读写操作次数 (Input/Output Operations Per Second, IOPS)

### 扩充卡与界面

主板上面通常会预留多个扩充界面的插槽， 这些插槽依据历史沿革，包括 PCI/AGP/PCI-X/PCIe 等等

由于 PCIe速度快到太好用了，因此几乎所有的卡都以 PCIe 来设计

### 主板

#### **发挥扩充卡效能须考虑的插槽位置**

卡插在哪个插槽上面效能最好，卡安装在哪个插槽上面，对效能而言也是影响很大

#### **设备** **I/O** **地址与** **IRQ** **中断信道**

一般来说，不能有两个装置使用同一个 I/O 地址， 否则系统就会不晓得该如何运作这两个装置了。而除了 I/O 地址之外，还有个IRQ 中断(Interrupt)。

各装置可以透过 IRQ 中断信道来告知 CPU 该装置的工作情况，以方便 CPU 进行工作分配的任务。

#### **CMOS** **与** **BIOS**

##### CMOS

CMOS 主要的功能为记录主板上面的重要参数， 包括系统时间、CPU 电压与频率、各项设备的 I/O 地址与 IRQ 等，由于这些数据的记录要花费电力，因此主板上面才有电池。

##### BIOS

BIOS 为写入到主板上某一块 flash 或EEPROM 的程序，他可以在开机的时候执行，以加载 CMOS 当中的参数， 并尝试呼叫储存装置中的开机程序，进一步进入操作系统当中。

#### **连接接口设备的接口**

*    PS/2 界面：这原本是常见的键盘与鼠标的接口，不过目前渐渐被 USB 接口取代，甚至较新的主板可能就不再提供 PS/2 界面了；
*    USB 界面：通常只剩下 USB 2.0 与 USB 3.0，为了方便区分，USB 3.0 为蓝色的插槽颜色喔！
*    声音输出、输入与麦克风：这个是一些圆形的插孔，而必须你的主板上面有内建音效芯片时，才会有这三个东西；
*    RJ-45 网络头：如果有内建网络芯片的话，那么就会有这种接头出现。 这种接头有点类似电话接头，不过内部有八蕊线。接上网络线后在这个接头上会有灯号亮起。
*    HDMI：如果有内建显示芯片的话，可能就会提供这个与屏幕连接的界面。这种接口可以同时传输声音与影像， 目前也是电视机屏幕的主流连接接口。

### 电源供应器

因为 Power 的用料不同，电源供应的稳定度也会差很多。

#### **能源转换率**

电源供应器出厂前会有一些测试数据，最好挑选高转换率的电源供应器。 所谓的高转换率指的是『输出的功率/输入的功率』。

## 数字系统

所谓的十进制指的是逢十进一位， 因此在个位数归为零而十位数写成 1。所以所谓的二进制，就是逢二就前进一位的意思。

### 文字编码系统

当我们要写入文件的文字数据时，该文字数据会由编码对照表将该文字转成数字后，再存入文件当中。同样的，当我们要将文件内容的数据读出时，也会经过编码对照表将该数字转成对应的文字后，再显示到屏幕上。

常用的英文编码表为 ASCII 系统，这个编码系统中， 每个符号(英文、数字或符号等)都会占用 1bytes 的记录， 因此总共会有 28=256 种变化。

Unicode 编码系统， 我们常常称呼的UTF8 或万国码的编码

### **软件程序运作**

#### 机器程序与编译程序

计算机只认识 0 与 1 而已，而且计算机最重要的运算与逻辑判断是在 CPU 内部， 而CPU 其实是具有微指令集的。因此，我们需要 CPU 帮忙工作时，就得要参考微指令集的内容， 然后撰写让 CPU 读的懂的脚本给 CPU 执行，这样就能够让 CPU 运作了。

*    需要了解机器语言：机器只认识 0 与 1，因此你必须要学习直接写给机器看的语言！ 这个地方相当的难呢！
*     需要了解所有硬件的相关功能函数：因为你的程序必须要写给机器看， 当然你就得要参考机器本身的功能， 然后针对该功能去撰写程序代码。例如，你要让 DVD 影片能够放映， 那就得要参考 DVD 光驱的硬件信息才行。万一你的系统有比较冷门的硬件，光是参考技术手册可能会昏倒～
*    程序不具有可移植性：每个 CPU 都有独特的微指令集，同样的，每个硬件都有其功能函数。 因此，你为 A 计算机写的程序，理论上是没有办法在 B 计算机上面运作的！而且程序代码的修改非常困难！ 因为是机器码，并不是人类看的懂得程序语言啊！
*    程序具有专一性：因为这样的程序必须要针对硬件功能函数来撰写， 如果已经开发了一支浏览器程序，想要再开发文件管理程序时，还是得从头再参考硬件的功能函数来继续撰写。

### 机器程序与编译程序

#### 操作系统

在早期想要让计算机执行程序就得要参考一堆硬件功能函数，并且学习机器语言才能够撰写程序。 同时每次写程序时都必须要重新改写，因为硬件与软件功能不见得都一致之故。那如果我能够将所有的硬件都驱动， 并且提供一个发展软件的参考接口来给工程师开发软件的话，那发展软件不就变的非常的简单了？那就是操作系统啦！

##### **操作系统核心**(Kernel)

操作系统(Operating System, OS)其实也是一组程序， 这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。

核心主要在管控硬件与提供相关的能力(例如存取硬盘、网络功能、CPU 资源取得等)， 这些管理的动作是非常的重要的，如果使用者能够直接使用到核心的话，万一用户不小心将核心程序停止或破坏， 将会导致整个系统的崩溃！

<u>核心程序所放置到内存当中的区块是受保护的</u>！ 并且开机后就一直常驻在内存当中。

##### **系统呼叫(System Call)**

计算机系统主要由硬件构成，然后核心程序主要在管理硬件，提供合理的计算机系统资源分配(包括

CPU 资源、内存使用资源等等)， 因此只要硬件不同(如 x86 架构与RISC 架构的 CPU)，核心就得要进行修改才行。

为了保护核心，并且让程序设计师比较容易开发软件，因此操作系统除了核心程序之外，通常还会提供一整组开发接口，那就是<u>系统呼叫层</u>。

*    操作系统的核心层直接参考硬件规格写成， 所以同一个操作系统程序不能够在不一样的硬件架构下运作。
*    操作系统只是在管理整个硬件资源，包括 CPU、内存、输入输出装置及文件系统文件。 
*    <u>应用程序的开发都是参考操作系统提供的开发接口， 所以该应用程序只能在该操作系统上面运作而已，不可以在其他操作系统上面运作的。</u>

##### **核心功能**

*    系统呼叫接口(System call interface)

*    程序管理(Process control).

*    内存管理(Memory management)

     系统所有的程序代码与数据都必须要先存放在内存当中。

*    文件系统管理(Filesystem management)

*    装置的驱动(Device drivers)

### **操作系统与驱动程序**

那操作系统该如何驱动这块新的显示适配器？为了克服这个问题，操作系统通常会提供一个开发接口给硬件开发商，让他们可以根据这个接口设计可以驱动他们硬件的『驱动程序』， 如此一来，只要使用者安装驱动程序后，自然就可以在他们的操作系统上面驱动这块显示适配器了。

*    操作系统必须要能够驱动硬件，如此应用程序才能够使用该硬件功能；
*    一般来说，操作系统会提供开发接口，让开发商制作他们的驱动程序；
*    要使用新硬件功能，必须要安装厂商提供的驱动程序才行；
*    驱动程序是由厂商提供的，与操作系统开发者无关。

### 应用程序

应用程序是参考操作系统提供的开发接口所开发出来<u>软件</u>，这些软件可以让用户操作，以达到某些计算机的功能利用。

## 总结

*    计算器的定义为：『接受用户输入指令与数据，经由中央处理器的数学与逻辑单元运算处理后，以产生或储存成有用的信息』；
*    计算机的五大单元包括：输入单元、输出单元、控制单元、算数逻辑单元、记忆单元五大部分。其中CPU占有控制、算术逻辑单元，记忆单元又包含主存储器与辅助内存；
*    数据会流进/流出内存是 CPU 所发布的控制命令，而CPU 实际要处理的数据则完全来自于主存储器；
*    CPU 依设计理念主要分为：精简指令集(RISC)与复杂指令集(CISC)系统；
*    关于CPU 的频率部分：外频指的是CPU 与外部组件进行数据传输时的速度，倍频则是CPU 内部用来加速工作效能的一个倍数， 两者相乘才是 CPU 的频率速度；
*    新的 CPU 设计中，已经将北桥的内存控制芯片整合到 CPU 内，而 CPU 与主存储器、显示适配器沟通的总线通常称为系统总线。 南桥就是所谓的输入输出(I/O)总线，主要在联系硬盘、USB、网络卡等接口设备；
*    CPU 每次能够处理的数据量称为字组大小(word size)，字组大小依据 CPU 的设计而有 32 位与 64 位。 我们现在所称的计算机是 32 或 64 位主要是依据这个 CPU 解析的字组大小而来的！
*    个人计算机的主存储器主要组件为动态随机存取内存(Dynamic Random Access Memory, DRAM)， 至于 CPU内部的第二层快取则使用静态随机存取内存(Static Random Access Memory, SRAM)；
*    BIOS(Basic Input Output System)是一套程序，这套程序是写死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器(Read Only Memory, ROM)；
*    目前主流的外接卡界面大多为 PCIe 界面，且最新为 PCIe 3.0，单信道速度高达 1GBytes/s
*    常见的显示适配器连接到屏幕的界面有 HDMI/DVI/D-Sub/Display port 等等。HDMI 可同时传送影像与声音。·    传统硬盘的组成为：圆形磁盘盘、机械手臂、 磁盘读取头与主轴马达所组成的，其中磁盘盘的组成为扇区、磁道与磁柱；
*    磁盘连接到主板的界面大多为 SATA 或 SAS，目前桌机主流为 SATA 3.0，理论极速可达 600Mbytes/s。
*    常见的文字编码为 ASCII，繁体中文编码主要有 Big5 及 UTF8 两种，目前主流为 UTF8
*    操作系统(Operating System, OS)其实也是一组程序， 这组程序的重点在于管理计算机的所有活动以及驱动系统中的所有硬件。
*    计算机主要以二进制作为单位，常用的磁盘容量单位为 bytes，其单位换算为 1 Byte = 8bits。
*    操作系统仅在驱动与管理硬件，而要使用硬件时，就得需要透过应用软件或者是壳程序(shell)的功能， 来呼叫操作系统操纵硬件工作。目前称为操作系统的，除了上述功能外，通常已经包含了日常工作所需要的应用软件在内了。

# **Linux 是什么与如何学习**

## **Linux** **是什么**

Linux 就是一套操作系统

由于不同的硬件他的功能函数并不相同，例如 IBM 的 Power CPU 与 Intel 的 x86 架构就是不一样！所以同一套操作系统是无法在不同的硬件平台上面运作的！

如果你想要让 x86 上面跑的那套操作系统也能够在 Power CPU 上运作时，就得要将该操作系统进行修改才行。如果能够参考硬件的功能函数并据以修改你的操作系统程序代码， 那经过改版后的操作系统就能够在另一个硬件平台上面运作了。 这个动作我们通常就称为<u>『软件移植』</u>了！

## Linux历史

*    Unix 的前身是由贝尔实验室(Bell lab.)的 Ken Thompson 利用汇编语言写成的， 后来在 1971-1973 年间由Dennis Ritchie 以C 程序语言进行改写，才称为 Unix。
*    1977 年由Bill Joy 释出 BSD (Berkeley Software Distribution)，这些称为Unix-like 的操作系统。
*    1984 年由Andrew Tanenbaum 开始制作Minix 操作系统，该系统可以提供原始码以及软件；
*    1984 年由Richard Stallman 提倡 GNU 计划，倡导自由软件(Free software)， 强调其软件可以『自由的取得、复制、修改与再发行』，并规范出 GPL 授权模式， 任何GPL(General Public License)软件均不可单纯仅贩卖其软件，也不可修改软件授权。
*    1991 年由芬兰人Linus Torvalds 开发出Linux 操作系统。简而言之，Linux 成功的地方主要在于：Minix(Unix), GNU, Internet, POSIX 及虚拟团队的产生。

## 总结

操作系统(Operation System)主要在管理与驱动硬件，因此必须要能够管理内存、管理装置、 负责行程管理以及系·    统呼叫等等。因此，只要能够让硬件准备妥当(Ready)的情况， 就是一个健全的操作系统了。

*    符合 Open source 理念的授权相当多，比较知名的如 Apache / BSD / GPL / MIT 等。
*    Linux 本身就是个最阳春的操作系统，其开发网站设立在 http://www.kernel.org，我们亦称 Linux 操作系统最底层的数据为『核心(Kernel)』。
*    从 Linux kernel 3.0 开始，已经舍弃奇数、偶数的核心版本规划，新的规划使用主线版本 (MainLine) 为依据， 并提供长期支持版本 (longterm) 来加强某些功能的持续维护。
*    Linux distributions 的组成含有：『Linux Kernel + Free Software + Documentations(Tools) + 可完全安装的程序』所制成的一套完整的系统。
*    常见的 Linux distributions 分类有『商业、社群』分类法，或『RPM、DPKG』分类法
*    学习 Linux 最好从头由基础开始学习，找到一本适合自己的书籍，加强实作才能学会

# **主机规划与磁盘分区**

## **Linux 与硬件的搭配**

### 认识计算机的硬件配备

计算机主机的硬件配备与这部主机未来的功能是很有相关性的

因此目前硬件评论界有所谓的『每瓦效能』的单位， 每瓦电力所发挥的效能越高，当然代表越省电

并非所有的产品都会支持特定的操作系统，这牵涉到硬件开发商是否有意愿提供适当的驱动程序之故。因此，当我们想要购买或者是升级某些计算机组件时，应该要特别注意该硬件是否有针对您的操作系统提供适当的驱动程序， 否则，买了无法使用

### 选择与Linux 搭配的主机配备

较早期的硬件配备也可能由于保存的问题或者是电子零件老化的问题， 导致这样的计算机系统反而非常容易在运作过程中出现不明的当机情况

*    CPU

CPU 只要不是老旧到会让你的硬件系统当机的都能够支持

*    RAM

主存储器是越大越好！事实上在 Linux 服务器中，主存储器的重要性比 CPU 还要高的多！因为如果主存储器不够大， 就会使用到硬盘的内存置换空间(swap)。 而由计算器概论的内容我们知道硬盘比内存的速度要慢的多， 所以主存储器太小可能会影响到整体系统的效能的！

*    Hard Disk

由于数据量与数据存取频率的不同，对于硬盘的要求也不相同。

>    磁盘阵列(RAID)是利用硬件技术将数个硬盘整合成为一个大硬盘的方法，操作系统只会看到最后被整合起来的大硬盘。 由于磁盘阵列是由多个硬盘组成，所以可以达成速度效能、备份等任务。

*    VGA

对于不需要X Window 的服务器来说，显示适配器算是最不重要的一个组件了！你只要有显示适配器能够让计算机启动，那就够了。 但如果需要 X window 系统时，你的显示适配器最好能够拥有 32MB 以上的内存容量。

*    Network Interface Card

网络卡是服务器上面最重要的组件之一了！目前的主板大多拥有内建 10/100/1000Mbps 的超高速以太网络卡。但要注意的是，不同的网络卡的功能还是有点差异。

*    光盘、软盘、键盘与鼠标

### 各硬件装置在 Linux 中的文件名

『在 Linux 系统中，每个装置都被当成一个文件来对待』

在 Linux 这个系统当中，几乎所有的硬件装置文件都在/dev 这个目录内

| 装置                 | 装置在 Linux 内的文件名                                      |
| -------------------- | ------------------------------------------------------------ |
| SCSI/SATA/USB 硬盘机 | /dev/sd[a-p]                                                 |
| USB 快闪碟           | /dev/sd[a-p] (与 SATA 相同)                                  |
| VirtI/O 界面         | /dev/vd[a-p] (用于虚拟机内)                                  |
| 软盘驱动器           | /dev/fd[0-7]                                                 |
| 打印机               | /dev/lp[0-2] (25 针打印机)  /dev/usb/lp[0-15] (USB 界面)     |
| 鼠标                 | /dev/input/mouse[0-15] (通用)  /dev/psaux (PS/2 界面) /dev/mouse (当前鼠标) |
| CDROM/DVDROM         | /dev/scd[0-1] (通用)  /dev/sr[0-1] (通用，CentOS 较常见)  /dev/cdrom (当前 CDROM) |
| 磁带机               | /dev/ht0 (IDE 界面)  /dev/st0 (SATA/SCSI 界面)  /dev/tape (当前磁带) |
| IDE 硬盘机           | /dev/hd[a-d] (旧式系统才有)                                  |

## **磁盘分区**

### 磁盘连接的方式与装置文件名的关系

个人计算机常见的磁盘接口有两种，分别是SATA 与SAS 接口， 目前的主流是 SATA 接口。

正常的实体机器大概使用的都是 /dev/sd[a-] 的磁盘文件名，至于虚拟机环境底下，为了加速，可能就会使用 /dev/vd[a-p] 这种装置文件名

再以 SATA 接口来说，由于 SATA/USB/SAS 等磁盘接口都是使用 SCSI 模块来驱动的， 因此这些接口的磁盘装置文件名都是/dev/sd[a-p]的格式。 所以 SATA/USB 接口的磁盘根本就没有一定的顺序

>    例题：
>
>    如果你的 PC 上面有两个 SATA 磁盘以及一个 USB 磁盘，而主板上面有六个 SATA 的插槽。这两个 SATA 磁盘分别安插在主板上的 SATA1, SATA5 插槽上， 请问这三个磁盘在 Linux 中的装置文件名为何？
>
>    答：
>
>    由于是使用侦测到的顺序来决定装置文件名，并非与实际插槽代号有关，因此装置的文件名如下：
>
>    \1.  SATA1 插槽上的檔名：/dev/sda
>
>    \2.  SATA5 插槽上的檔名：/dev/sdb
>
>    \3.   USB 磁盘(开机完成后才被系统捉到)：/dev/sdc

磁盘的组成主要有磁盘盘、机械手臂、磁盘读取头与主轴马达所组成， 而数据的写入其实是在磁盘盘上面。磁盘盘上面又可细分出扇区(Sector)与磁道(Track)两种单位， 其中扇区的物理量设计有两种大小，分别是 512bytes 与 4Kbytes。

### MSDOS(MBR) 与 GPT 磁盘分区表(partition table)

通常磁盘可能有多个磁盘盘，所有磁盘盘的同一个磁道我们称为磁柱 (Cylinder)， 通常那是文件系统的最小单位，也就是分区槽的最小单位

#### **MSDOS (MBR)** **分区表格式与限制**

 早期的 Linux 系统为了兼容于 Windows 的磁盘，因此使用的是支持 Windows 的 <u>MBR</u>(Master Boot Record, 主要开机纪录区) 的方式来处理开机管理程序与分区表

*    主要启动记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有 446 bytes
*    分区表(partition table)：记录整颗硬盘分区的状态，有 64 bytes由于分区表所在区块仅有 64 bytes 容量，因此最多仅能有四组记录区，每组记录区记录了该区段的启始与结束的磁柱号码。 

当你的操作系统为Windows 时，那么第一到第四个分区槽的代号应该就是 C, D, E, F。当你有资料要写入 F 槽时， 你的数据会被写入这颗磁盘的 301~400 号磁柱之间的意思。

*    其实所谓的『分区』只是针对那个 64 bytes 的分区表进行设定而已！
*    硬盘默认的分区表仅能写入四组分区信息
*    这四组分区信息我们称为主要(Primary)或延伸(Extended)分区槽
*    分区槽的最小单位『通常』为磁柱(cylinder)
*    当系统要写入磁盘时，一定会参考磁盘分区表，才能针对某个分区槽进行数据的处理

##### 分区原因

*    数据的安全性

因为每个分区槽的数据是分开的！所以，当你需要将某个分区槽的数据重整时，例如你要将计算机中Windows 的C 槽重新安装一次系统时， 可以将其他重要数据移动到其他分区槽，例如将邮件、桌面数据移动到D 槽去，那么 C 槽重灌系统并不会影响到 D 槽！ 所以善用分区槽，可以让妳的数据更安全。

*    系统的效能考虑

由于分区槽将数据集中在某个磁柱的区段，例如上图当中第一个分区槽位于磁柱号码 1~100 号，如此一来当有数据要读取自该分区槽时， 磁盘只会搜寻前面 1~100 的磁柱范围，由于数据集中了，将有助于数据读取的速度与效能！所以说，分区是很重要的！

延伸分区的目的是使用额外的扇区来记录分区信息，延伸分区本身并不能被拿来格式化。

##### MBR 主要分区、延伸分区与逻辑分区的特性：

*    主要分区与延伸分区最多可以有四笔(硬盘的限制)
*    延伸分区最多只能有一个(操作系统的限制)
*    逻辑分区是由延伸分区持续切割出来的分区槽；
*    能够被格式化后，作为数据存取的分区槽为主要分区与逻辑分区。延伸分区无法格式化；
*    逻辑分区的数量依操作系统而不同，在 Linux 系统中 SATA 硬盘已经可以突破 63 个以上的分区限制；

#### **GUID partition table, GPT 磁盘分区表**

*    LBA0 (MBR 相容区块)

与 MBR 模式相似的，这个兼容区块也分为两个部份，一个就是跟之前 446 bytes 相似的区块，储存了第一阶段的开机管理程序！ 而在原本的分区表的纪录区内，这个兼容模式仅放入一个特殊标志的分区，用来表示此磁盘为 GPT 格式之意。

*    LBA1 (GPT 表头纪录)

这个部份纪录了分区表本身的位置与大小，同时纪录了备份用的 GPT 分区 (就是前面谈到的在最后 34 个 LBA 区块) 放置的位置， 同时放置了分区表的检验机制码 (CRC32)，操作系统可以根据这个检验码来判断 GPT 是否正确。若有错误，还可以透过这个纪录区来取得备份的 GPT(磁盘最后的那个备份区块) 来恢复 GPT 的正常运作！

*    LBA2-33 (实际纪录分区信息处)

从 LBA2 区块开始，每个 LBA 都可以纪录 4 笔分区纪录，所以在默认的情况下，总共可以有 4*32 = 128 笔分区纪录喔！因为每个 LBA 有 512bytes，因此每笔纪录用到 128 bytes 的空间，除了每笔纪录所需要的标识符与相关的纪录之外，GPT 在每笔纪录中分别提供了 64bits 来记载开始/结束的扇区号码，因此，GPT 分区表对于单一分区槽来说， 他的最大容量限制就会在『 264 * 512bytes = 263 * 1Kbytes = 233*TB = 8 ZB 』，要注意 1ZB = 230TB 啦！ 

### 开机流程中的 BIOS 与 UEFI 开机检测程序

#### **BIOS** **搭配** **MBR/GPT** **的开机流程**

<u>CMOS</u> 是记录各项硬件参数且嵌入在主板上面的储存器，<u>BIOS</u> 则是一个写入到主板上的一个韧体(再次说明， 韧体就是写入到硬件上的一个软件程序)。

<u>这个 BIOS 就是在开机的时候，计算机系统会主动执行的第一个程序了！</u>

BIOS 会去分析计算机里面有哪些储存设备，我们以硬盘为例，BIOS 会依据使用者的设定去取得能够开机的硬盘， 并且到该硬盘里面去读取第一个扇区的 MBR 位置。MBR 这个仅有 446 bytes 的硬盘容量里面会放置最基本的开机管理程序， 此时 BIOS 就功成圆满，而接下来就是 MBR 内的开机管理程序的工作了。

流程

*    BIOS**：开机主动执行的韧体，会认识第一个可开机的装置；**
*    MBR**：第一个可开机装置的第一个扇区内的主要启动记录区块，内含开机管理程序；**
*    开机管理程序(boot loader)**：一支可读取核心文件来执行的软件；**
     *    提供选单**：用户可以选择不同的开机项目，这也是多重引导的重要功能！**
     *    载入核心文件**：直接指向可开机的程序区段来开始操作系统；**
     *    转交其他** **loader**：将开机管理功能转交给其他 loader 负责。
          *    开机管理程序除了可以安装在 MBR 之外， 还可以安装在每个分区槽的启动扇区(boot sector)
          *    每个分区槽都拥有自己的启动扇区(boot sector)
          *    图中的系统槽为第一及第二分区槽，
          *    实际可开机的核心文件是放置到各分区槽内的！
          *    loader 只会认识自己的系统槽内的可开机核心文件，以及其他 loader 而已；loader 可直接指向或者是间接将管理权转交给另一个管理程序
*    核心文件：开始操作系统的功能...

#### **UEFI BIOS** **搭配** **GPT** **开机的流程**

UEFI (Unified Extensible Firmware Interface) 这个统一可延伸韧体界面

UEFI 使用 C 程序语言，比起使用汇编语言的传统 BIOS 要更容易开发



#### 传统 BIOS 与 UEFI 的差异

| 比较项目               | 传统 BIOS                                                  | UEFI               |
| ---------------------- | ---------------------------------------------------------- | ------------------ |
| 使用程序语言           | 汇编语言                                                   | C  语言            |
| 硬件资源控制           | 使用中断 (IRQ) 管理不可变的内存存取  不可变得输入/输出存取 | 使用驱动程序与协议 |
| 处理器运作环境         | 16  位                                                     | CPU  保护模式      |
| 扩充方式               | 透过 IRQ 连结                                              | 直接加载驱动程序   |
| 第三方厂商支持         | 较差                                                       | 较佳且可支持多平台 |
| 图形化能力             | 较差                                                       | 较佳               |
| 内建简化操作系统前环境 | 不支援                                                     | 支援               |

与 BIOS 模式相比，虽然 UEFI 可以直接取得 GPT 的分区表，不过最好依旧拥有 BIOS boot 的分区槽支持， 同时，为了与 windows 兼容，并且提供其他第三方厂商所使用的 UEFI 应用程序储存的空间，你必须要格式化一个 vfat 的文件系统， 大约提供 512MB 到 1G 左右的容量，以让其他 UEFI 执行较为方便。

### Linux 安装模式下，磁盘分区的选择(极重要)

#### **目录树结构** **(directory tree)**

整个 Linux 系统最重要的地方就是在于目录树架构。 所谓的目录树架构(directory tree)就是以根目录为主，然后向下呈现分支状的目录结构的一种文件架构。 

所以，整个目录树架构最重要的就是那个根目录(root directory)，这个根目录的表示方法为一条斜线『**/**』， 所有的文件都与目录树有关。

所有的文件都是由根目录(/)衍生来的，而次目录之下还能够有其他的数据存在。

#### 文件系统与目录树的关系(挂载)

所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下； 也就是说， 进入该目录就可以读取该分区槽的意思。

这个动作我们称为『挂载』，那个进入点的目录我们称为『挂载点』。

#### **distributions** **安装时，挂载点与磁盘分区的规划**

**强烈建议使用『自定义安装, Custom 』这个安装模式**

*    自定义安装『Custom』
*    建议分区的方法：预留一个备用的剩余磁盘容量

**选择 Linux 安装程序提供的默认硬盘分区方式**

## 主机的服务规划与硬件的关系

### **打造** **Windows** **与** **Linux** **共存的环境**

开机流程与多重引导

### NAT(达成IP分享器的功能)

通常小型企业或者是学校单位大多仅会有一条对外的联机，然后全公司/学校内的计算机全部透过这条联机连到因特网上。

### SAMBA加入Windows网络上的芳邻)

我们可以使用 Linux 上面的 SAMBA 这个软件来达成加入 Windows 网芳的功能。

SAMBA 的效能不错， 也没有客户端联机数的限制，相当适合于一般学校环境的文件服务器(file server)的角色。

这种服务器由于分享的数据量较大，对于系统的网络卡与硬盘的大小及速度就比较重要， 如果你还针对不同的用户提供文件服务器功能，那么/home 这个目录可以考虑独立出来，并且加大容量。

### Mail邮件服务器

在 mail server 上面，重要的也是硬盘容量与网络卡速度，在此情境中，也可以将/var 目录独立出来，并加大容量。

### **Web(WWW 服务器)**

WWW 服务器几乎是所有的网络主机都会安装的一个功能，因为他除了可以提供 Internet 的 WWW 联机之外， 很多在网络主机上面的软件功能(例如某些分析软件所提供的最终分析结果的画面)也都使用 WWW 作为显示的接口。

### **DHCP(提供客户端自动取得 IP 的功能)**

客户端计算机只要选择『自动取得 IP』，其他的，就是你系统管理员在 DHCP 服务器上面设定一下即可。

### **FTP**

对于 FTP 的硬件需求来说，硬盘容量与网络卡好坏相关性较高。

## 主机硬盘的主要规划

所谓的『数据安全』并不是指数据被网络cracker 所破坏， 而是指『当主机系统的硬件出现问题时，你的文件数据能否安全的保存』之意。

硬盘的分区技巧需要对于 Linux 文件结构有相当程度的认知之后才能够做比较完善的规划

*    最简单的分区方法

仅分区出根目录与内存置换空间( / & swap )即可。

*    稍微麻烦一点的方式

先分析这部主机的未来用途，然后根据用途去分析需要较大容量的目录， 以及读写较为频繁的目录，将这些重要的目录分别独立出来而不与根目录放在一起， 那当这些读写较频繁的磁盘分区槽有问题时，至少不会影响到根目录的系统数据

在默认的CentOS 环境中，底下的目录是比较符合容量大且(或)读写频繁的目录啰：

*    boot
*    /
*    /home
*    /var
*    Swap

## 总结

*    新添购计算机硬件配备时，需要考虑的角度有『游戏机/工作机』、『效能/价格比』、『效能/消耗瓦数』、『支持度』等；
*    旧的硬件配备可能由于保存的问题或者是电子零件老化的问题，导致计算机系统非常容易在运作过程中出现不明的当机情况
*    Red Hat 的硬件支持
*    在 Linux 系统中，每个装置都被当成一个文件来对待，每个装置都会有装置文件名。
*    磁盘装置文件名通常分为两种，实际 SATA/USB 装置文件名为/dev/sd[a-p]，而虚拟机的装置可能为/dev/vd[a-p]

*    磁盘的第一个扇区主要记录了两个重要的信息，分别是： (1)主要启动记录区(Master Boot Record, MBR)： 可以安装开机管理程序的地方，有 446 bytes (1)分区表(partition table)：记录整颗硬盘分区的状态，有 64 bytes；
*    磁盘的 MBR 分区方式中，主要与延伸分区最多可以有四个，逻辑分区的装置文件名号码，一定由 5 号开始；
*    如果磁盘容量大于 2TB 以上时，系统会自动使用 GPT 分区方式来处理磁盘分区。
*    GPT 分区已经没有延伸与逻辑分区槽的概念，你可以想象成所有的分区都是主分区！
*    某些操作系统要使用 GPT 分区时，必须要搭配 UEFI 的新型 BIOS 格式才可安装使用。
*    开机的流程由：BIOS-->MBR-->-->boot loader-->核心文件；
*    boot loader 的功能主要有：提供选单、加载核心、转交控制权给其他 loader
*    boot loader 可以安装的地点有两个，分别是 MBR 与 boot sector
*    Linux 操作系统的文件使用目录树系统，与磁盘的对应需要有『挂载』的动作才行；
*    新手的简单分区，建议只要有/及 swap 两个分区槽即可

